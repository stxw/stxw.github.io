<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FZU-1686 神龙的难题</title>
    <url>/acm/fzu-1686/</url>
    <content><![CDATA[<p>舞蹈链重复覆盖问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.fzu.edu.cn/problem.php?pid=1686" target="_blank" rel="noopener">http://acm.fzu.edu.cn/problem.php?pid=1686</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;中文题，又可以偷懒了！</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;计算出地图上所有怪物的个数，假设为$K$个，给怪物从1到K进行编号。然后枚举每一种神龙攻击的情况，也就是枚举神龙攻击范围的左上角坐标，行坐标一共有$n-n1+1$种情况，列坐标一共有$m-m1+1$种情况，所以一共有$(n-n1+1) \times (m-m1+1)$种攻击情况，假设为$P=(n-n1+1) \times (m-m1+1)$。然后构建一个$P \times K$的矩阵$M$，然后第$i$种攻击情况能攻击到第$j$个怪物，则$M$的第$i$行的第$j$个元素为$1$，否则为$0$。最后用舞蹈链对$M$求重复覆盖问题就好了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.fzu.edu.cn/problem.php?pid=1686 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N * MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = MAX_N * MAX_N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[MAX_ROWS * MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_min_ans;</span><br><span class="line">	<span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">int</span> ans, *select_rows;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove_rep</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].r].l = nd[i].l;</span><br><span class="line">			nd[nd[i].l].r = nd[i].r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume_rep</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].u; i != col; i = nd[i].u)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].l].r = i;</span><br><span class="line">			nd[nd[i].r].l = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算取得答案最少需要的行数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_min_rows</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, k, num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> v[MAX_COLS];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[i] == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].d; j != i; j = nd[j].d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k = nd[j].r; k != j; k = nd[k].r)</span><br><span class="line">				&#123;</span><br><span class="line">					v[nd[k].col] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs_rep</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断是否超过了界限 */</span></span><br><span class="line">		<span class="keyword">int</span> mr = get_min_rows();</span><br><span class="line">		<span class="keyword">if</span>(limit != <span class="number">-1</span> &amp;&amp; len + mr &gt; limit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_min_ans == <span class="literal">true</span> &amp;&amp; ans != <span class="number">-1</span> &amp;&amp; len + mr &gt;= ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(select_rows != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[len] = nd[i].row;</span><br><span class="line">			&#125;</span><br><span class="line">			remove_rep(i);</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove_rep(j);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs_rep(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is_min_ans == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; res)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume_rep(j);</span><br><span class="line">			&#125;</span><br><span class="line">			resume_rep(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> is_min_ans = <span class="literal">true</span>, <span class="keyword">int</span> select_rows[] = <span class="literal">NULL</span>, <span class="keyword">int</span> limit = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;is_min_ans = is_min_ans;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		<span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		ans = dfs_rep(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link;</span><br><span class="line"></span><br><span class="line">dance_link dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, n1, m1;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, x, y, ans;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">map</span>[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>[i][j] != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					k++;</span><br><span class="line">					<span class="built_in">map</span>[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n1, &amp;m1);</span><br><span class="line"></span><br><span class="line">		dl.init((n - n1 + <span class="number">1</span>) * (m - m1 + <span class="number">1</span>), k);</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(x = <span class="number">0</span>; x + n1 &lt;= n; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(y = <span class="number">0</span>; y + m1 &lt;= m; y++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(i = x; i &lt; x + n1; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(j = y; j &lt; y + m1; j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">map</span>[i][j] != <span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							dl.add_node(k + <span class="number">1</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = dl.solve(<span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1754 I Hate It</title>
    <url>/acm/hdu-1754/</url>
    <content><![CDATA[<p>线段树模板题，求区间最大值</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1754</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;中文题，不解释</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;跟上一题一样，还是线段树的模板题，只不过把求区间和改成了求区间最大值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=1754 */</span></span><br><span class="line"><span class="comment">/* AC 702MS 4060K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[MAX_N];</span><br><span class="line"><span class="keyword">int</span> seg_tree[<span class="number">4</span> * MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, mid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(left == right - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		seg_tree[root] = num[left];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		a = build(root * <span class="number">2</span>, left, mid);</span><br><span class="line">		b = build(root * <span class="number">2</span> + <span class="number">1</span>, mid, right);</span><br><span class="line">		seg_tree[root] = (a &gt; b) ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, mid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(left == right - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		seg_tree[root] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; mid)</span><br><span class="line">		&#123;</span><br><span class="line">			seg_tree[root * <span class="number">2</span>] = update(root * <span class="number">2</span>, left, mid, index, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			seg_tree[root * <span class="number">2</span> + <span class="number">1</span>] = update(root * <span class="number">2</span> + <span class="number">1</span>, mid, right, index, val);</span><br><span class="line">		&#125;</span><br><span class="line">		a = seg_tree[root * <span class="number">2</span>];</span><br><span class="line">		b = seg_tree[root * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">		seg_tree[root] = (a &gt; b) ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, mid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(qr &lt;= left || right &lt;= ql)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ql &lt;= left &amp;&amp; right &lt;= qr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		a = query(root * <span class="number">2</span>, left, mid, ql, qr);</span><br><span class="line">		b = query(root * <span class="number">2</span> + <span class="number">1</span>, mid, right, ql, qr);</span><br><span class="line">		<span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, x, y;</span><br><span class="line">	<span class="keyword">int</span> i, ans;</span><br><span class="line">	<span class="keyword">char</span> req;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		build(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			getchar();</span><br><span class="line">			req = getchar();</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">			x -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(req == <span class="string">'Q'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = query(<span class="number">1</span>, <span class="number">0</span>, n, x, y);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(req == <span class="string">'U'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				update(<span class="number">1</span>, <span class="number">0</span>, n, x, y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2102 A计划</title>
    <url>/acm/hdu-2102/</url>
    <content><![CDATA[<p>简单搜索题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2102" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2102</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;中文题，就不解释了哈。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>&emsp;&emsp;从起点开始搜索四个方向就好了，用深度优先搜索和广度优先搜索都行，遇到#就搜索另一层。需要注意的是传送到另一层后，不只是要判断是不是墙，还要判断是不是#，因为按题意来说，这种情况会一直在两层之间传送，然后走不出去，如果不特判的话，会在另一层继续搜索。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">2</span>][MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, front, back;</span><br><span class="line">	<span class="keyword">int</span> book[<span class="number">2</span>][MAX_N][MAX_N];</span><br><span class="line">	node que[<span class="number">2</span> * MAX_N * MAX_N];</span><br><span class="line">	node tep;</span><br><span class="line">	<span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	que[<span class="number">0</span>] = (node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	front = <span class="number">0</span>;</span><br><span class="line">	back = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">	book[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(front != back)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tep = que[front];</span><br><span class="line">			tep.x += dir[i][<span class="number">0</span>];</span><br><span class="line">			tep.y += dir[i][<span class="number">1</span>];</span><br><span class="line">			tep.t++;</span><br><span class="line">			<span class="keyword">if</span>(tep.x &lt; <span class="number">0</span> || tep.x &gt;= n || tep.y &lt; <span class="number">0</span> || tep.y &gt;= m || tep.t &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[tep.z][tep.x][tep.y] == <span class="string">'#'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tep.z = !tep.z;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[tep.z][tep.x][tep.y] == <span class="string">'*'</span> || <span class="built_in">map</span>[tep.z][tep.x][tep.y] == <span class="string">'#'</span> || book[tep.z][tep.x][tep.y] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[tep.z][tep.x][tep.y] == <span class="string">'P'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> tep.t;</span><br><span class="line">			&#125;</span><br><span class="line">			book[tep.z][tep.x][tep.y] = <span class="number">1</span>;</span><br><span class="line">			que[back] = tep;</span><br><span class="line">			back++;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c, i, ans;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">	<span class="keyword">while</span>(c--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">map</span>[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">map</span>[<span class="number">1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = solve();</span><br><span class="line">		<span class="keyword">if</span>(ans == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2295 Radar</title>
    <url>/acm/hdu-2295/</url>
    <content><![CDATA[<p>舞蹈链重复覆盖问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2295" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2295</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出n个城市，m个雷达站，以及它们的坐标，每个雷达站有一个自身为中心的圆形覆盖范围，每个雷达站的覆盖范围半径R相等。现在要使得每个城市都能被雷达站覆盖，且最多只能启用k个雷达站，求满足条件的R的最小值。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;二分搜索R的范围，对于每个范围的中值，先假设R等于这个中值，然后构建一个m×n的矩阵，矩阵的第i行第j列表示第i个雷达是否能覆盖第j个城市，如果能为1，否则为0。然后用舞蹈链的重复覆盖算法来，判断覆盖所有城市最少需要的雷达站个数p。最后根据p是否大于k来更新R的范围，直到小于精度值。<br>&emsp;&emsp;这里精度值最好设小一点，设成1e-6就WA了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=2295 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EXP = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(point b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - b.x) * (x - b.x) + (y - b.y) * (y - b.y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = MAX_N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[MAX_ROWS * MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_min_ans;</span><br><span class="line">	<span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">int</span> ans, *select_rows;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(col_nds, <span class="number">0</span>, <span class="keyword">sizeof</span>(col_nds));</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="built_in">memset</span>(row_head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(row_head));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].l].r = nd[i].r;</span><br><span class="line">			nd[nd[i].r].l = nd[i].l;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].l].r = i;</span><br><span class="line">			nd[nd[i].r].l = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算取得答案最少需要的行数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_min_rows</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, k, num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> v[MAX_COLS];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[i] == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].d; j != i; j = nd[j].d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k = nd[j].r; k != j; k = nd[k].r)</span><br><span class="line">				&#123;</span><br><span class="line">					v[nd[k].col] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断是否超过了界限 */</span></span><br><span class="line">		<span class="keyword">if</span>(limit != <span class="number">-1</span> &amp;&amp; len + get_min_rows() &gt; limit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(select_rows != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[len] = nd[i].row;</span><br><span class="line">			&#125;</span><br><span class="line">			remove(i);</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(j);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is_min_ans == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; res)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(j);</span><br><span class="line">			&#125;</span><br><span class="line">			resume(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> is_min_ans = <span class="literal">true</span>, <span class="keyword">int</span> select_rows[] = <span class="literal">NULL</span>, <span class="keyword">int</span> limit = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;is_min_ans = is_min_ans;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		<span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		ans = dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link;</span><br><span class="line"></span><br><span class="line">dance_link dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, n, m, k;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">double</span> left, right, mid;</span><br><span class="line">	point city[MAX_N], radar[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> dist;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;city[i].x, &amp;city[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;radar[i].x, &amp;radar[i].y);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		left = <span class="number">0.0</span>;</span><br><span class="line">		right = <span class="number">1500.0</span>;</span><br><span class="line">		<span class="keyword">while</span>(right - left &gt;= EXP)</span><br><span class="line">		&#123;</span><br><span class="line">			mid = (right + left) / <span class="number">2.0</span>;</span><br><span class="line">			dl.init(m, n);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					dist = radar[i].distance(city[j]);</span><br><span class="line">					<span class="keyword">if</span>(radar[i].distance(city[j]) &lt;= mid)</span><br><span class="line">					&#123;</span><br><span class="line">						dl.add_node(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			len = dl.solve(<span class="literal">false</span>, <span class="literal">NULL</span>, k);</span><br><span class="line">			<span class="keyword">if</span>(len != <span class="number">-1</span> &amp;&amp; dl.solve() &lt;= k)</span><br><span class="line">			&#123;</span><br><span class="line">				right = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				left = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-3085 Nightmare Ⅱ</title>
    <url>/acm/hdu-3085/</url>
    <content><![CDATA[<p>双向广度优先搜索</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3085" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3085</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一个n×m的迷宫，迷宫里有些地方是墙，有些地方是空地，迷宫里还有两只鬼，鬼可以分身，以每秒两步的速度向附近扩散，而且鬼可以穿墙。erriyue和他的女朋友在迷宫里面，erriyue每秒钟可以走3步，他的女朋友每秒钟可以走一步。问erriyue能否在在鬼抓到他或他女朋友之前，与他女朋友会合，如果可以输出最少需要的时间，否则输出-1。</p>
<ul>
<li>墙用#表示</li>
<li>空地用.表示</li>
<li>鬼的初始位置用M表示</li>
<li>erriyue的初始位置用M表示</li>
<li>erriyue的女朋友初始位置用G表示</li>
</ul>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>&emsp;&emsp;以erriyue和他女朋友为原点，使用双向广度优先搜索路径，同时使用曼哈顿距离（也就是两个方向上的距离和）来判断会不会被鬼追上。双向的广度优先搜索相当单向的耗时少一点，用曼哈顿距离就可以不用把鬼加到队列里了，省了空间。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// const int MAX_N = 2 + 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">char</span> book[<span class="number">2</span>][MAX_N][MAX_N];</span><br><span class="line"><span class="built_in">queue</span>&lt;point&gt; que[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &gt; b) ? a - b : b - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_point</span><span class="params">(point p, point zs[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(p.x, zs[<span class="number">0</span>].x) + <span class="built_in">abs</span>(p.y, zs[<span class="number">0</span>].y) &lt;= <span class="number">2</span> * t || </span><br><span class="line">		<span class="built_in">abs</span>(p.x, zs[<span class="number">1</span>].x) + <span class="built_in">abs</span>(p.y, zs[<span class="number">1</span>].y) &lt;= <span class="number">2</span> * t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">step_one</span><span class="params">(<span class="keyword">int</span> mg, point zs[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, pn;</span><br><span class="line">	point front, tep;</span><br><span class="line"></span><br><span class="line">	pn = que[mg].size();</span><br><span class="line">	<span class="keyword">while</span>(pn--)</span><br><span class="line">	&#123;</span><br><span class="line">		front = que[mg].front();</span><br><span class="line">		que[mg].pop();</span><br><span class="line">		<span class="keyword">if</span>(check_point(front, zs, t))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tep = front;</span><br><span class="line">			tep.x += dir[i][<span class="number">0</span>];</span><br><span class="line">			tep.y += dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(tep.x &lt; <span class="number">0</span> || tep.x &gt;= n || tep.y &lt; <span class="number">0</span> || tep.y &gt;= m)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(check_point(tep, zs, t) || mp[tep.x][tep.y] == <span class="string">'X'</span> || book[mg][tep.x][tep.y] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(book[!mg][tep.x][tep.y] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			book[mg][tep.x][tep.y] = <span class="number">1</span>;</span><br><span class="line">			que[mg].push(tep);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(point ms, point gs, point zs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">	book[<span class="number">0</span>][ms.x][ms.y] = <span class="number">1</span>;</span><br><span class="line">	book[<span class="number">1</span>][gs.x][gs.y] = <span class="number">1</span>;</span><br><span class="line">	que[<span class="number">0</span>].push(ms);</span><br><span class="line">	que[<span class="number">1</span>].push(gs);</span><br><span class="line">	t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(que[<span class="number">0</span>].empty() == <span class="literal">false</span> || que[<span class="number">1</span>].empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t++;</span><br><span class="line">		<span class="keyword">if</span>(step_one(<span class="number">0</span>, zs, t) == <span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">		<span class="keyword">if</span>(step_one(<span class="number">0</span>, zs, t) == <span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">		<span class="keyword">if</span>(step_one(<span class="number">0</span>, zs, t) == <span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">		<span class="keyword">if</span>(step_one(<span class="number">1</span>, zs, t) == <span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, i, j, k, ans;</span><br><span class="line">	point ms, gs, zs[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">		getchar();</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, mp[i]);</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp[i][j] == <span class="string">'M'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ms = (point)&#123;i, j&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j] == <span class="string">'G'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					gs = (point)&#123;i, j&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j] == <span class="string">'Z'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					zs[k] = (point)&#123;i, j&#125;;</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(que[<span class="number">0</span>].empty() == <span class="literal">false</span>) que[<span class="number">0</span>].pop();</span><br><span class="line">		<span class="keyword">while</span>(que[<span class="number">1</span>].empty() == <span class="literal">false</span>) que[<span class="number">1</span>].pop();		</span><br><span class="line">		ans = solve(ms, gs, zs);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-3335 Divisibility</title>
    <url>/acm/hdu-3335/</url>
    <content><![CDATA[<p>舞蹈链重复覆盖问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3335" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3335</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出n个数，需要从里面选择一些出来，但是如果选择了某个数k的话，则能被k整除或k能整除的数都不能再选了，问最多能选择多少个数。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这题原理不是太懂，参考网上大佬的解题方法AC的，方法如下：<br>&emsp;&emsp;首先建立一个n×n的整除关系矩阵，如果第i个数于第j个数有整除关系，则矩阵的第i行第j列为1，用这个矩阵来运行舞蹈链重复覆盖算法，取结果最大值作为答案。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=3335 */</span></span><br><span class="line"><span class="comment">/* AC 15MS 1252K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舞蹈链算法，用于求重复覆盖问题 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link_rep</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = MAX_N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[MAX_ROWS * MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].r].l = nd[i].l;</span><br><span class="line">			nd[nd[i].l].r = nd[i].r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].u; i != col; i = nd[i].u)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].l].r = i;</span><br><span class="line">			nd[nd[i].r].l = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_rows</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, k, num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> v[MAX_COLS];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[i] == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].d; j != i; j = nd[j].d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k = nd[j].r; k != j; k = nd[k].r)</span><br><span class="line">				&#123;</span><br><span class="line">					v[nd[k].col] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mr = get_rows();</span><br><span class="line">		<span class="keyword">if</span>(ans != <span class="number">-1</span> &amp;&amp; len + mr &lt; ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans &lt; len)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = len;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			remove(i);</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(j);</span><br><span class="line">			&#125;</span><br><span class="line">			dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(j);</span><br><span class="line">			&#125;</span><br><span class="line">			resume(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link_rep;</span><br><span class="line"></span><br><span class="line">dance_link_rep dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, n;</span><br><span class="line">	<span class="keyword">int</span> i, j, ans;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dl.init(n, n);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i] % a[j] == <span class="number">0</span> || a[j] % a[i] == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dl.add_node(i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = dl.solve();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4069 Squiggly Sudoku</title>
    <url>/acm/hdu-4069/</url>
    <content><![CDATA[<p>变形的数独问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4069" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4069</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;普通的数独问题是要求每个3×3的子矩阵里不能有相同的数字，这题将3×3的子矩阵改成了题目给定的连通区域，每个连通区域的面积为9，其他要求不变。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;与用舞蹈链解决普通数独问题类似，求解前需要用深度优先搜索找出每个连通区域的范围，然后给每个连通区域编号，用这个编号去代替解决普通数独问题的3×3子矩阵的编号。<br>&emsp;&emsp;这题比较麻烦的是，需要判断是否有两个以上的解，所以在用舞蹈链搜索的时候记录解的个数，如果解的个数大于2个就停止搜索。这里需要注意的是，找到第一个解后需要用数组把搜索过程中选择的行保存下来，因为下一次搜索不一定能得到第二个正确答案，但是在求解的过程中会取得第一个答案选择的行覆盖掉，所以不能用搜索选择的行来作为正确答案选择的行。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=4069 */</span></span><br><span class="line"><span class="comment">/* AC 764MS 1324K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N * MAX_N * MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = <span class="number">4</span> * MAX_N * MAX_N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[MAX_ROWS * <span class="number">4</span> * MAX_N];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> path[MAX_ROWS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ansl, *select_rows;</span><br><span class="line">	<span class="keyword">int</span> ans_num;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里移除 */</span></span><br><span class="line">		nd[nd[col].l].r = nd[col].r;</span><br><span class="line">		nd[nd[col].r].l = nd[col].l;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行移除 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = nd[j].d;</span><br><span class="line">				nd[nd[j].d].u = nd[j].u;</span><br><span class="line">				col_nds[nd[j].col]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里恢复 */</span></span><br><span class="line">		nd[nd[col].l].r = col;</span><br><span class="line">		nd[nd[col].r].l = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行恢复 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = j;</span><br><span class="line">				nd[nd[j].d].u = j;</span><br><span class="line">				col_nds[nd[j].col]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans_num++;</span><br><span class="line">			ansl = len;</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[i] = path[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		remove(select_col);</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			path[len] = nd[i].row;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans_num &gt; <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		resume(select_col);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> select_rows[] = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ans_num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans_num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link;</span><br><span class="line"></span><br><span class="line">dance_link dl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> grp;</span><br><span class="line">	<span class="keyword">int</span> dir[<span class="number">4</span>];</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">node mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> grp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt;= <span class="number">9</span> || mp[x][y].grp != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mp[x][y].grp = grp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[x][y].dir[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(x + dirs[i][<span class="number">0</span>], y + dirs[i][<span class="number">1</span>], grp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, cas, i, j, k, in, row, ans_num;</span><br><span class="line">	<span class="keyword">int</span> x[dl.MAX_ROWS], y[dl.MAX_ROWS], num[dl.MAX_ROWS], ans[dl.MAX_ROWS], ansl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span>(cas = <span class="number">1</span>; cas &lt;= t; cas++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in);</span><br><span class="line">				mp[i][j].num = in % <span class="number">16</span>;</span><br><span class="line">				in = in &gt;&gt; <span class="number">4</span>;</span><br><span class="line">				<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					mp[i][j].dir[k] = in &amp; <span class="number">1</span>;</span><br><span class="line">					in = in &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				mp[i][j].grp = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		k = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp[i][j].grp == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(i, j, k);</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dl.init(<span class="number">9</span> * <span class="number">9</span> * <span class="number">9</span>, <span class="number">4</span> * <span class="number">9</span> * <span class="number">9</span>);</span><br><span class="line">		row = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp[i][j].num == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++)</span><br><span class="line">					&#123;</span><br><span class="line">						dl.add_node(row, i * <span class="number">9</span> + j + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">81</span> + i * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">162</span> + j * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">243</span> + (mp[i][j].grp - <span class="number">1</span>) * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">						x[row] = i;</span><br><span class="line">						y[row] = j;</span><br><span class="line">						num[row] = k + <span class="number">1</span>;</span><br><span class="line">						row++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					k = mp[i][j].num - <span class="number">1</span>;</span><br><span class="line">					dl.add_node(row, i * <span class="number">9</span> + j + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">81</span> + i * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">162</span> + j * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">243</span> + (mp[i][j].grp - <span class="number">1</span>) * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					x[row] = i;</span><br><span class="line">					y[row] = j;</span><br><span class="line">					num[row] = k + <span class="number">1</span>;</span><br><span class="line">					row++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans_num = dl.solve(ans);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, cas);</span><br><span class="line">		<span class="keyword">if</span>(ans_num &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"No solution\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans_num == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; dl.ansl; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				i = x[ans[k]];</span><br><span class="line">				j = y[ans[k]];</span><br><span class="line">				mp[i][j].num = num[ans[k]];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d"</span>, mp[i][j].num);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Multiple Solutions\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">144 18 112 208 80 25 54 144 48</span></span><br><span class="line"><span class="comment">135 38 147 80 121 128 97 130 32</span></span><br><span class="line"><span class="comment">137 32 160 144 114 167 208 0 32</span></span><br><span class="line"><span class="comment">192 100 160 160 208 96 183 192 101</span></span><br><span class="line"><span class="comment">209 80 39 192 86 48 136 80 114</span></span><br><span class="line"><span class="comment">152 48 226 144 112 160 160 149 48</span></span><br><span class="line"><span class="comment">128 0 112 166 215 96 160 128 41</span></span><br><span class="line"><span class="comment">128 39 153 32 209 80 101 136 35</span></span><br><span class="line"><span class="comment">192 96 200 67 80 112 208 68 96 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">144 48 144 81 81 16 53 144 48</span></span><br><span class="line"><span class="comment">128 96 224 144 48 128 103 128 38</span></span><br><span class="line"><span class="comment">163 208 80 0 37 224 209 0 32</span></span><br><span class="line"><span class="comment">135 48 176 192 64 112 176 192 104</span></span><br><span class="line"><span class="comment">192 101 128 89 80 82 32 150 48</span></span><br><span class="line"><span class="comment">149 48 224 208 16 48 224 192 33</span></span><br><span class="line"><span class="comment">128 0 114 176 135 0 80 112 169</span></span><br><span class="line"><span class="comment">137 32 148 32 192 96 176 144 32</span></span><br><span class="line"><span class="comment">192 96 193 64 80 80 96 192 96</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">144 88 48 217 16 16 80 112 176</span></span><br><span class="line"><span class="comment">224 176 129 48 128 40 208 16 37</span></span><br><span class="line"><span class="comment">145 32 128 96 196 96 176 136 32</span></span><br><span class="line"><span class="comment">192 32 227 176 144 80 96 192 32</span></span><br><span class="line"><span class="comment">176 192 80 98 160 145 80 48 224</span></span><br><span class="line"><span class="comment">128 48 144 80 96 224 183 128 48</span></span><br><span class="line"><span class="comment">128 36 224 144 51 144 32 128 105</span></span><br><span class="line"><span class="comment">131 64 112 136 32 192 36 224 176</span></span><br><span class="line"><span class="comment">224 208 80 64 64 116 192 83 96</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Case 1:</span></span><br><span class="line"><span class="comment">521439678</span></span><br><span class="line"><span class="comment">763895124</span></span><br><span class="line"><span class="comment">984527361</span></span><br><span class="line"><span class="comment">346182795</span></span><br><span class="line"><span class="comment">157964832</span></span><br><span class="line"><span class="comment">812743956</span></span><br><span class="line"><span class="comment">235678419</span></span><br><span class="line"><span class="comment">479216583</span></span><br><span class="line"><span class="comment">698351247</span></span><br><span class="line"><span class="comment">Case 2:</span></span><br><span class="line"><span class="comment">No solution</span></span><br><span class="line"><span class="comment">Case 3:</span></span><br><span class="line"><span class="comment">Multiple Solutions</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU_4081 Qin Shi Huangs National Road System</title>
    <url>/acm/hdu_4081/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4081" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4081</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>&emsp;&emsp;During the Warring States Period of ancient China(476 BC to 221 BC), there were seven kingdoms in China —- they were Qi, Chu, Yan, Han, Zhao, Wei and Qin. Ying Zheng was the king of the kingdom Qin. Through 9 years of wars, he finally conquered all six other kingdoms and became the first emperor of a unified China in 221 BC. That was Qin dynasty —- the first imperial dynasty of China(not to be confused with the Qing Dynasty, the last dynasty of China). So Ying Zheng named himself “Qin Shi Huang” because “Shi Huang” means “the first emperor” in Chinese.<br>&emsp;&emsp;Qin Shi Huang undertook gigantic projects, including the first version of the Great Wall of China, the now famous city-sized mausoleum guarded by a life-sized Terracotta Army, and a massive national road system. There is a story about the road system:<br>&emsp;&emsp;There were n cities in China and Qin Shi Huang wanted them all be connected by n-1 roads, in order that he could go to every city from the capital city Xianyang.<br>&emsp;&emsp;Although Qin Shi Huang was a tyrant, he wanted the total length of all roads to be minimum,so that the road system may not cost too many people’s life. A daoshi (some kind of monk) named Xu Fu told Qin Shi Huang that he could build a road by magic and that magic road would cost no money and no labor. But Xu Fu could only build ONE magic road for Qin Shi Huang. So Qin Shi Huang had to decide where to build the magic road. Qin Shi Huang wanted the total length of all none magic roads to be as small as possible, but Xu Fu wanted the magic road to benefit as many people as possible —- So Qin Shi Huang decided that the value of A/B (the ratio of A to B) must be the maximum, which A is the total population of the two cites connected by the magic road, and B is the total length of none magic roads.<br>&emsp;&emsp;Would you help Qin Shi Huang?<br>&emsp;&emsp;A city can be considered as a point, and a road can be considered as a line segment connecting two points.</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>&emsp;&emsp;The first line contains an integer t meaning that there are t test cases(t &lt;= 10).<br>&emsp;&emsp;For each test case:<br>&emsp;&emsp;The first line is an integer n meaning that there are n cities(2 &lt; n &lt;= 1000).<br>&emsp;&emsp;Then n lines follow. Each line contains three integers X, Y and P ( 0 &lt;= X, Y &lt;= 1000, 0 &lt; P &lt; 100000). (X, Y) is the coordinate of a city and P is the population of that city.<br>&emsp;&emsp;It is guaranteed that each city has a distinct location.</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>&emsp;&emsp;For each test case, print a line indicating the above mentioned maximum ratio A/B. The result should be rounded to 2 digits after decimal point.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2<br>4<br>1 1 20<br>1 2 30<br>200 2 80<br>200 1 100<br>3<br>1 1 20<br>1 2 30<br>2 2 40</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>65.00<br>70.00</p>
</blockquote>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;有n个城市，给出每个城市的坐标和人口数，秦始皇想修一些路，使得这n个城市之间可以互相连通，同时希望花费最少的劳动力（修的路的长度总和越大，花费的劳动力越多）。有一个叫徐福的道士可以用魔法帮秦始皇修一条路，并且不需要额外的劳动力，不过徐福希望他用魔法修的路能帮到更多的人。所以他们最终决定采集A/B最小的方案，A是通过魔道连接的两个城市的总人口，而B是不用魔法修的路的总长度。求A/B的最小值。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;次小生成树的变形。先求出最小生成树的总长度mst_l和maxd数组，然后枚举图上的每一条边，作为用魔法修的路，那么不用魔法修的路的总长度为mst_l-maxd[i][j]，再根据两个城市的总人口，就可以算出A/B的最小值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=4081 */</span></span><br><span class="line"><span class="comment">/* AC 109MS 16968K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, p;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">node nd[MAX_N];</span><br><span class="line"><span class="keyword">int</span> mst[MAX_N];</span><br><span class="line"><span class="keyword">double</span> mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">double</span> maxd[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">double</span> min, mst_l;</span><br><span class="line">	<span class="keyword">double</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = mp[<span class="number">0</span>][i];</span><br><span class="line">		mst[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(maxd, <span class="number">0</span>, <span class="keyword">sizeof</span>(maxd));</span><br><span class="line"></span><br><span class="line">	mst_l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = <span class="number">1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] != <span class="number">-1</span> &amp;&amp; min &gt; dist[j])</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min == <span class="number">1e10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mst_l += min;</span><br><span class="line">		dist[k] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] == <span class="number">-1</span> &amp;&amp; j != k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> pre = mst[k];</span><br><span class="line">				maxd[j][k] = (maxd[j][pre] &gt; mp[pre][k]) ? maxd[j][pre] : mp[pre][k];</span><br><span class="line">				maxd[k][j] = maxd[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] != <span class="number">-1</span> &amp;&amp; dist[j] &gt; mp[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = mp[k][j];</span><br><span class="line">				mst[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mst_l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">double</span> mst_l, mst_sl, temp, ans;</span><br><span class="line"></span><br><span class="line">	mst_l = prim();</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = mst_l - maxd[i][j];</span><br><span class="line">			<span class="keyword">if</span>(ans &lt; (nd[i].p + nd[j].p) / temp)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = (nd[i].p + nd[j].p) / temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, i, j;</span><br><span class="line">	<span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;nd[i].x, &amp;nd[i].y, &amp;nd[i].p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				mp[i][j] = <span class="built_in">pow</span>(nd[i].x - nd[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(nd[i].y - nd[j].y, <span class="number">2</span>);</span><br><span class="line">				mp[i][j] = <span class="built_in">sqrt</span>(mp[i][j]);</span><br><span class="line">				mp[j][i] = mp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = solve();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST-1017 Exact cover</title>
    <url>/acm/hust-1017/</url>
    <content><![CDATA[<p>精确覆盖问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://www.hustoj.org/problem/1017" target="_blank" rel="noopener">http://www.hustoj.org/problem/1017</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一个大小为n×m，只包含0和1的矩阵，需要选出矩阵中的某些行，使得这些行组成的子矩阵在每一列上有且只有一个1。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这题是舞蹈链的模板题，标准的精确覆盖问题。第一次接触舞蹈链算法，参考大佬的博客才看懂的，关于舞蹈链算法，参考自<a href="https://www.cnblogs.com/grenet/p/3145800.html" target="_blank" rel="noopener">https://www.cnblogs.com/grenet/p/3145800.html</a>，大佬解释的非常详细了，在此感谢<a href="https://www.cnblogs.com/grenet/" target="_blank" rel="noopener">万仓一黍</a>大佬的解释，我比较懒，就不复述了。代码参考了<a href="https://www.cnblogs.com/ZShogg/p/3288980.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZShogg/p/3288980.html</a>，也感谢<a href="https://www.cnblogs.com/ZShogg/" target="_blank" rel="noopener">Hogg</a>大佬的代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://www.hustoj.org/problem/1017 */</span></span><br><span class="line"><span class="comment">/* 测试样例通过了，因为oj的问题（HUST OJ不支持特判），无法提交 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NODE = MAX_N * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">	<span class="keyword">int</span> row, col;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, node_size;</span><br><span class="line">node nd[MAX_NODE];</span><br><span class="line"><span class="keyword">int</span> row_head[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		nd[i].u = i;</span><br><span class="line">		nd[i].d = i;</span><br><span class="line">		nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">		nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nd[<span class="number">0</span>].l = m;</span><br><span class="line">	nd[m].r = <span class="number">0</span>;</span><br><span class="line">	node_size = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">	<span class="built_in">memset</span>(row_head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(row_head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">	nd[node_size].row = row;</span><br><span class="line">	nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">	nd[node_size].u = col;</span><br><span class="line">	nd[node_size].d = nd[col].d;</span><br><span class="line">	nd[nd[col].d].u = node_size;</span><br><span class="line">	nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">	<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		row_head[row] = node_size;</span><br><span class="line">		nd[node_size].l = node_size;</span><br><span class="line">		nd[node_size].r = node_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">		nd[node_size].r = row_first;</span><br><span class="line">		nd[node_size].l = nd[row_first].l;</span><br><span class="line">		nd[nd[row_first].l].r = node_size;</span><br><span class="line">		nd[row_first].l = node_size;</span><br><span class="line">	&#125;</span><br><span class="line">	node_size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将第col列从十字链表里移除 */</span></span><br><span class="line">	nd[nd[col].l].r = nd[col].r;</span><br><span class="line">	nd[nd[col].r].l = nd[col].l;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将与第col列里节点有关的行移除 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[j].u].d = nd[j].d;</span><br><span class="line">			nd[nd[j].d].u = nd[j].u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将第col列从十字链表里恢复 */</span></span><br><span class="line">	nd[nd[col].l].r = col;</span><br><span class="line">	nd[nd[col].r].l = col;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将与第col列里节点有关的行恢复 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[j].u].d = j;</span><br><span class="line">			nd[nd[j].d].u = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ans[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, res, select_col;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">	<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">	remove(select_col);</span><br><span class="line">	<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[len] = nd[i].row;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			remove(nd[j].col);</span><br><span class="line">		&#125;</span><br><span class="line">		res = dfs(ans, len + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">		&#123;</span><br><span class="line">			resume(nd[j].col);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	resume(select_col);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, c, len;</span><br><span class="line">	<span class="keyword">int</span> ans[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">				add_node(i, k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len = dfs(ans, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, len);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" %d"</span>, ans[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">3 1 4 7</span></span><br><span class="line"><span class="comment">2 1 4</span></span><br><span class="line"><span class="comment">3 4 5 7</span></span><br><span class="line"><span class="comment">3 3 5 6</span></span><br><span class="line"><span class="comment">4 2 3 6 7</span></span><br><span class="line"><span class="comment">2 2 7</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>hust</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1084 Square Destroyer</title>
    <url>/acm/poj-1084/</url>
    <content><![CDATA[<p>舞蹈链重复覆盖问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1084" target="_blank" rel="noopener">http://poj.org/problem?id=1084</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一个用火柴拼成的$n \times n$的网格（一共需要$2n(n+1)$根火柴），按顺序给每个火柴编号，然后去掉其中$k$个火柴。问至少还需要去掉几个火柴，使得网格没有任何正方形。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这题可以用舞蹈链的重复覆盖算法解决，也有大佬用迭代深搜AC了。用舞蹈链的话关键在于构建覆盖关系矩阵，可以将正方形作为列，火柴作为行，如果第j个正方形的完整依赖于第i根火柴，则第i行的第j列为1，否则为0。这样题目就转化为选择最少的火柴，使得这些火柴能覆盖所有正方形，最后用使用舞蹈链重复覆盖算法模板就可以了。<br>&emsp;&emsp;比较麻烦的是，遍历所有的正方形需要枚举正方形左上角顶点坐标，然后再枚举正方形的边长，最后还要转一圈，遍历组成该正方形的所有火柴，这循环写的我想哭/(ㄒoㄒ)/~~。然后就是题目在求解前要先删除一些火柴，对于每个要删除的火柴，删的时候关键不是要删除火柴所在的行，而是要删除火柴能覆盖的正方形所对应的列。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舞蹈链算法，用于求重复覆盖问题 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link_rep</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = <span class="number">2</span> * MAX_N * MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = <span class="number">2</span> * MAX_N * MAX_N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[MAX_ROWS * MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_min_ans;</span><br><span class="line">	<span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">int</span> ans, *select_rows;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].r].l = nd[i].l;</span><br><span class="line">			nd[nd[i].l].r = nd[i].r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].u; i != col; i = nd[i].u)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[i].l].r = i;</span><br><span class="line">			nd[nd[i].r].l = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算取得答案最少需要的行数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_min_rows</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, k, num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> v[MAX_COLS];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[i] == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].d; j != i; j = nd[j].d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k = nd[j].r; k != j; k = nd[k].r)</span><br><span class="line">				&#123;</span><br><span class="line">					v[nd[k].col] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断是否超过了界限 */</span></span><br><span class="line">		<span class="keyword">int</span> mr = get_min_rows();</span><br><span class="line">		<span class="keyword">if</span>(limit != <span class="number">-1</span> &amp;&amp; len + mr &gt; limit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_min_ans == <span class="literal">true</span> &amp;&amp; ans != <span class="number">-1</span> &amp;&amp; len + mr &gt;= ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(select_rows != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[len] = nd[i].row;</span><br><span class="line">			&#125;</span><br><span class="line">			remove(i);</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(j);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is_min_ans == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; res)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(j);</span><br><span class="line">			&#125;</span><br><span class="line">			resume(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> is_min_ans = <span class="literal">true</span>, <span class="keyword">int</span> select_rows[] = <span class="number">0</span>, <span class="keyword">int</span> limit = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;is_min_ans = is_min_ans;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		<span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		ans = dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link_rep;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dance_link_rep dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, n;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, s, p, x, y, c, flag, ans;</span><br><span class="line">	<span class="keyword">int</span> rows, cols;</span><br><span class="line">	<span class="keyword">int</span> ds[<span class="number">2</span> * MAX_N], dst;</span><br><span class="line">	<span class="keyword">int</span> ms[<span class="number">2</span> * MAX_N][<span class="number">2</span> * MAX_N];</span><br><span class="line">	<span class="keyword">int</span> as[dl.MAX_ROWS * dl.MAX_COLS][<span class="number">2</span>], ast;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;dst);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dst; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ds[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(ms, <span class="number">0</span>, <span class="keyword">sizeof</span>(ms));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>, c = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = !(i % <span class="number">2</span>); j &lt;= <span class="number">2</span> * n; j += <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ms[i][j] = c;</span><br><span class="line">				<span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; dst; s++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(c == ds[s])</span><br><span class="line">					&#123;</span><br><span class="line">						ms[i][j] = <span class="number">-1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				c++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c = <span class="number">1</span>;</span><br><span class="line">		ast = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; <span class="number">2</span> * n; x += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; <span class="number">2</span> * n; y += <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(s = <span class="number">1</span>; s + x / <span class="number">2</span> &lt;= n &amp;&amp; s + y / <span class="number">2</span> &lt;= n; s++)</span><br><span class="line">				&#123;</span><br><span class="line">					k = ast;</span><br><span class="line">					flag = <span class="number">0</span>;</span><br><span class="line">					i = x;</span><br><span class="line">					j = y + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; s; p++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(ms[i][j] == <span class="number">-1</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							flag = <span class="number">-1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						as[k][<span class="number">0</span>] = ms[i][j];</span><br><span class="line">						as[k][<span class="number">1</span>] = c;</span><br><span class="line">						k++;</span><br><span class="line">						j += <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					i += <span class="number">1</span>;</span><br><span class="line">					j -= <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; s; p++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(ms[i][j] == <span class="number">-1</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							flag = <span class="number">-1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						as[k][<span class="number">0</span>] = ms[i][j];</span><br><span class="line">						as[k][<span class="number">1</span>] = c;</span><br><span class="line">						k++;</span><br><span class="line">						i += <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					i -= <span class="number">1</span>;</span><br><span class="line">					j -= <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; s; p++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(ms[i][j] == <span class="number">-1</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							flag = <span class="number">-1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						as[k][<span class="number">0</span>] = ms[i][j];</span><br><span class="line">						as[k][<span class="number">1</span>] = c;</span><br><span class="line">						k++;</span><br><span class="line">						j -= <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					i -= <span class="number">1</span>;</span><br><span class="line">					j += <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; s; p++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(ms[i][j] == <span class="number">-1</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							flag = <span class="number">-1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						as[k][<span class="number">0</span>] = ms[i][j];</span><br><span class="line">						as[k][<span class="number">1</span>] = c;</span><br><span class="line">						k++;</span><br><span class="line">						i -= <span class="number">2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(flag != <span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ast = k;</span><br><span class="line">						c++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rows = <span class="number">2</span> * n * (n + <span class="number">1</span>);</span><br><span class="line">		cols = c - <span class="number">1</span>;</span><br><span class="line">		dl.init(rows, cols);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ast; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			dl.add_node(as[i][<span class="number">0</span>], as[i][<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = dl.solve(<span class="literal">true</span>, <span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1251 Jungle Roads</title>
    <url>/acm/poj-1251/</url>
    <content><![CDATA[<p>最小生成树问题-Kruskal算法</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1251" target="_blank" rel="noopener">http://poj.org/problem?id=1251</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出地图上的n个村庄，村庄之间存在一些双向路径，每条路径有一个权值。需要选出一些路径，使得所有的村庄之间可以相互连通，且选出路径的权值和要最小，求出最小的权值和。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;最小生成树的模板题，可以用Prim算法或者Kruskal算法求解，这里用的是Kruskal算法。<br>&emsp;&emsp;有个奇怪的问题，用c语言的<code>scanf()</code>来输入字符的话会Runtime Error，用c++的cin就没问题。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=1251 */</span></span><br><span class="line"><span class="comment">/* AC 0MS 716K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">set</span>[i] != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = find_root(<span class="built_in">set</span>, <span class="built_in">set</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(edge e[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k, ar, br;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">set</span>[MAX_N];</span><br><span class="line"></span><br><span class="line">	sort(e, e + m, cmp);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m &amp;&amp; k &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ar = find_root(<span class="built_in">set</span>, e[i].a);</span><br><span class="line">		br = find_root(<span class="built_in">set</span>, e[i].b);</span><br><span class="line">		<span class="keyword">if</span>(ar != br)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">set</span>[ar] = br;</span><br><span class="line">			ans += e[i].w;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w, ans;</span><br><span class="line">	<span class="keyword">char</span> a, b;</span><br><span class="line">	edge e[MAX_N * MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// while(scanf("%d", &amp;n) != EOF &amp;&amp; n &gt; 0)</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// getchar();</span></span><br><span class="line">			<span class="comment">// scanf("%c %d", &amp;a, &amp;k);</span></span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; k;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// getchar();</span></span><br><span class="line">				<span class="comment">// scanf("%c %d", &amp;b, &amp;w);</span></span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; b &gt;&gt; w;</span><br><span class="line">				e[m] = (edge)&#123;a - <span class="string">'A'</span>, b - <span class="string">'A'</span>, w&#125;;</span><br><span class="line">				m++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = kruskal(e, n, m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">A 2 B 12 I 25</span></span><br><span class="line"><span class="comment">B 3 C 10 H 40 I 8</span></span><br><span class="line"><span class="comment">C 2 D 18 G 55</span></span><br><span class="line"><span class="comment">D 1 E 44</span></span><br><span class="line"><span class="comment">E 2 F 60 G 38</span></span><br><span class="line"><span class="comment">F 0</span></span><br><span class="line"><span class="comment">G 1 H 35</span></span><br><span class="line"><span class="comment">H 1 I 35</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">A 2 B 10 C 40</span></span><br><span class="line"><span class="comment">B 1 C 20</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1287 Networking</title>
    <url>/acm/poj-1287/</url>
    <content><![CDATA[<p>最小生成树问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1287" target="_blank" rel="noopener">http://poj.org/problem?id=1287</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出P个节点和R条边的无向图，求最小生成树。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;最小生成树的模板题，可以用Prim算法或者Kruskal算法求解，Prim算法适合稠密图（点少边多），Kruskal算法适合稀疏图（点多边少）。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>Prim算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=1287 */</span></span><br><span class="line"><span class="comment">/* AC 16MS 380K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> mp[][MAX_N], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, min, ans;</span><br><span class="line">	<span class="keyword">int</span> book[MAX_N];</span><br><span class="line">	<span class="keyword">int</span> tree[MAX_N];</span><br><span class="line">	<span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">		tree[i] = <span class="number">0</span>;</span><br><span class="line">		dist[i] = mp[<span class="number">0</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	book[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	tree[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = <span class="number">0x1f1f1f1f</span>;</span><br><span class="line">		k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; min &gt; dist[j])</span><br><span class="line">			&#123;</span><br><span class="line">				k = j;</span><br><span class="line">				min = dist[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		book[k] = <span class="number">1</span>;</span><br><span class="line">		ans += mp[tree[k]][k];</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; mp[k][j] &lt; dist[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = mp[k][j];</span><br><span class="line">				tree[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> i, a, b, w, ans;</span><br><span class="line">	<span class="keyword">int</span> mp[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			a -= <span class="number">1</span>;</span><br><span class="line">			b -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(w &lt; mp[a][b])</span><br><span class="line">			&#123;</span><br><span class="line">				mp[a][b] = w;</span><br><span class="line">				mp[b][a] = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = prim(mp, n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=1287 */</span></span><br><span class="line"><span class="comment">/* AC 16MS 400K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">set</span>[i] != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = find_root(<span class="built_in">set</span>, <span class="built_in">set</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(edge e[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k, ar, br;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">set</span>[MAX_N];</span><br><span class="line"></span><br><span class="line">	sort(e, e + m, cmp);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m &amp;&amp; k &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ar = find_root(<span class="built_in">set</span>, e[i].a);</span><br><span class="line">		br = find_root(<span class="built_in">set</span>, e[i].b);</span><br><span class="line">		<span class="keyword">if</span>(ar != br)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">set</span>[ar] = br;</span><br><span class="line">			ans += e[i].w;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">edge e[MAX_N * MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, a, b, w, ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			e[i] = (edge)&#123;a, b, w&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans = kruskal(e, n, m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1166 敌兵布阵</title>
    <url>/acm/hdu-1166/</url>
    <content><![CDATA[<p>线段树模板题，求区间和</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1166</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;又是一道可以偷懒的中文题，开心！</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这是一道线段树的模板题，而且不加延迟标记也能AC。这题也可以用树状数组来做。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://acm.hdu.edu.cn/showproblem.php?pid=1166 */</span></span><br><span class="line"><span class="comment">/* AC 249MS 1928K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[MAX_N];</span><br><span class="line"><span class="keyword">int</span> seg_tree[<span class="number">4</span> * MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, mid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(left == right - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		seg_tree[root] = num[left];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		a = build(root * <span class="number">2</span>, left, mid);</span><br><span class="line">		b = build(root * <span class="number">2</span> + <span class="number">1</span>, mid, right);</span><br><span class="line">		seg_tree[root] = a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, <span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(left == right - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		seg_tree[root] += add;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; mid)</span><br><span class="line">		&#123;</span><br><span class="line">			seg_tree[root * <span class="number">2</span>] = update(root * <span class="number">2</span>, left, mid, index, add);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			seg_tree[root * <span class="number">2</span> + <span class="number">1</span>] = update(root * <span class="number">2</span> + <span class="number">1</span>, mid, right, index, add);</span><br><span class="line">		&#125;</span><br><span class="line">		seg_tree[root] = seg_tree[root * <span class="number">2</span>] + seg_tree[root * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, mid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(qr &lt;= left || right &lt;= ql)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ql &lt;= left &amp;&amp; right &lt;= qr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> seg_tree[root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		a = query(root * <span class="number">2</span>, left, mid, ql, qr);</span><br><span class="line">		b = query(root * <span class="number">2</span> + <span class="number">1</span>, mid, right, ql, qr);</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas, t, n, x, y;</span><br><span class="line">	<span class="keyword">int</span> i, ans;</span><br><span class="line">	<span class="keyword">char</span> req[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span>(cas = <span class="number">1</span>; cas &lt;= t; cas++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		build(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, cas);</span><br><span class="line">		<span class="keyword">while</span>(getchar(), <span class="built_in">scanf</span>(<span class="string">"%s"</span>, req) != EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(req[<span class="number">0</span>] == <span class="string">'E'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">			x -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(req[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = query(<span class="number">1</span>, <span class="number">0</span>, n, x, y);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(req[<span class="number">0</span>] == <span class="string">'A'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				update(<span class="number">1</span>, <span class="number">0</span>, n, x, y);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(req[<span class="number">0</span>] == <span class="string">'S'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				update(<span class="number">1</span>, <span class="number">0</span>, n, x, -y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1611 The Suspects</title>
    <url>/acm/poj-1611/</url>
    <content><![CDATA[<p>简单的并查集</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener">http://poj.org/problem?id=1611</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;有n个学生和m个团队，学生编号为0～n，一个学生可以属于多个团体。团体内如果有一个学生被怀疑感染了病毒，那么团体内所有学生都会被怀疑感染了病毒，初始时假设只有0号学生被怀疑感染了病毒，问一共有多少人会被怀疑感染了病毒。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;可以用并查集来解决，首先0号学生属于0号集合，对于每个团体，找到所有成员所在的集合编号，如果有一个成员属于0号集合，则把所有成员都合并到0号集合，如果没有成员属于0号集合，则将所有成员所属的集合合并成一个集合，集合编号任意。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=1611 */</span></span><br><span class="line"><span class="comment">/* AC 16MS 464K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">set</span>[i] != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = find_root(<span class="built_in">set</span>, <span class="built_in">set</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, num, ar, br, ans;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">set</span>[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF &amp;&amp; (n != <span class="number">0</span> || m != <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">set</span>[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">			<span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">				ar = find_root(<span class="built_in">set</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">				br = find_root(<span class="built_in">set</span>, num);</span><br><span class="line">				<span class="keyword">if</span>(br == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">set</span>[ar] = br;</span><br><span class="line">					ar = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">set</span>[br] = ar;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ar = find_root(<span class="built_in">set</span>, i);</span><br><span class="line">			<span class="keyword">if</span>(ar == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2236 Wireless Network</title>
    <url>/acm/poj-2236/</url>
    <content><![CDATA[<p>简单的并查集</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=2236" target="_blank" rel="noopener">http://poj.org/problem?id=2236</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;网断了！要把网络修好，电脑是通过无线来通信的，通信范围是d。也就是如果两台电脑没坏，且之间的距离小于d，那这两台电脑就可以相互通信。<br>&emsp;&emsp;一共有n台电脑，初始时每台电脑都是坏的，首先给出每台电脑的坐标，然后每次可以进行两种操作：<br>&emsp;&emsp;&emsp;&emsp;1. ‘O’操作，修好一台电脑<br>&emsp;&emsp;&emsp;&emsp;2. ‘S’操作，测试两台电脑是否可以通信<br>&emsp;&emsp;输出所有的测试结果，如果可以通信输出“SUCCESS”，否则输出“FAIL”。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;简单的并查集问题，对于’O’操作，遍历所有已经修好的电脑，如果之间的距离小于d，就合并。对于’S’操作，判断两台电脑是否在一个集合里。<br>&emsp;&emsp;注意’O’和’S’的输入，会接收终端的换行符。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=2236 */</span></span><br><span class="line"><span class="comment">/* AC 3329MS 328K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">set</span>[i] != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set</span>[i] = find_root(<span class="built_in">set</span>, <span class="built_in">set</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, d;</span><br><span class="line">	<span class="keyword">char</span> opt;</span><br><span class="line">	<span class="keyword">int</span> i, j, a, b, ar, br;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">set</span>[MAX_N], book[MAX_N];</span><br><span class="line">	point p[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;d);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		<span class="built_in">set</span>[i] = i;</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;opt) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="string">'O'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			ar = find_root(<span class="built_in">set</span>, a);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(book[i] == <span class="number">1</span> &amp;&amp; p[i].distance(p[a]) &lt;= (<span class="keyword">double</span>)d)</span><br><span class="line">				&#123;</span><br><span class="line">					br = find_root(<span class="built_in">set</span>, i);</span><br><span class="line">					<span class="built_in">set</span>[br] = ar;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			book[a] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="string">'S'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">			<span class="keyword">if</span>(book[a] == <span class="number">0</span> || book[b] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"FAIL\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ar = find_root(<span class="built_in">set</span>, a);</span><br><span class="line">			br = find_root(<span class="built_in">set</span>, b);</span><br><span class="line">			<span class="keyword">if</span>(ar == br)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"SUCCESS\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"FAIL\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2253 Frogger</title>
    <url>/acm/poj-2253/</url>
    <content><![CDATA[<p>单源最短路径变形-dijkstra算法</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">http://poj.org/problem?id=2253</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;湖上有n个石头，青蛙Freddy坐在1号石头上，青蛙Fiona坐在2号石头上，青蛙Freddy想要到Fiona的2号石头上（应该是只绅士青蛙）。但是湖水被污染了，他要尽量避免游泳，因此他需要利用其他石头来中转，与普通的路径长度定义不同，这里路径的长度定义为相邻两个石头距离的最大值。题目要求找出一条最短的路径，输出路径长度。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;解题方法与使用dijkstra算法解决普通单源最短路径问题类似，但是因为路径长度的定义不同，所以在初始化起点到其他节点的路径长度，和更新到其他点的最短路径的时候需要改一下。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=2253 */</span></span><br><span class="line"><span class="comment">/* AC 0MS 336K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">point p[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">double</span> min, max;</span><br><span class="line">	<span class="keyword">int</span> book[MAX_N];</span><br><span class="line">	<span class="keyword">double</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = p[start].distance(p[i]);</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[start] = <span class="number">0.0</span>;</span><br><span class="line">	book[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = <span class="number">1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k == end)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> dist[k];</span><br><span class="line">		&#125;</span><br><span class="line">		book[k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 计算起点经过k点到达j点的路径最大值 */</span></span><br><span class="line">				max = p[k].distance(p[j]);</span><br><span class="line">				<span class="keyword">if</span>(dist[k] &gt; max)</span><br><span class="line">				&#123;</span><br><span class="line">					max = dist[k];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(dist[j] &gt; max)</span><br><span class="line">				&#123;</span><br><span class="line">					dist[j] = max;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, t;</span><br><span class="line">	<span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(t = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n &gt;= <span class="number">2</span>; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = dijkstra(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>, t);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3f\n\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2387 Til the Cows Come Home</title>
    <url>/acm/poj-2387/</url>
    <content><![CDATA[<p>单源最短路问题-dijkstra算法</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=2387" target="_blank" rel="noopener">http://poj.org/problem?id=2387</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一个有n个点的图已经某些点之间的路径，求第n个点到第1个点的最短路径。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;标准的单源最短路径问题，可以用dijkstra算法来解决，也可以用Bellman-Ford算法和SPFA算法(可以解决含负边权的图)求解，不过我不会。小心可能会有重边。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=2387 */</span></span><br><span class="line"><span class="comment">/* AC 47MS 4332K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mp[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, min;</span><br><span class="line">	<span class="keyword">int</span> book[MAX_N];</span><br><span class="line">	<span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = mp[start][i];</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">	book[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = <span class="number">0x1f1f1f1f</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k == end)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> dist[k];</span><br><span class="line">		&#125;</span><br><span class="line">		book[k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; dist[j] &gt; dist[k] + mp[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = dist[k] + mp[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, a, b, w;</span><br><span class="line">	<span class="keyword">int</span> i, ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;t, &amp;n) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			a -= <span class="number">1</span>;</span><br><span class="line">			b -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(w &lt; mp[a][b])</span><br><span class="line">			&#123;</span><br><span class="line">				mp[a][b] = w;</span><br><span class="line">				mp[b][a] = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = dijkstra(n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-3074 Sudoku</title>
    <url>/acm/poj-3074/</url>
    <content><![CDATA[<p>用舞蹈链来解决数独问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=3074" target="_blank" rel="noopener">http://poj.org/problem?id=3074</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;标准的9×9数独问题，给出一个9×9的矩阵，需要填入1到9之间的数字，使得每一行、每一列以及每一个3×3子矩阵的数字都不重复。题目给出已经填了一部分数字的矩阵，需要将剩余部分填完。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;可以用舞蹈链的精确覆盖算法来解决数独问题。首先对于每个位置有9个可以填入的数字，共有9×9个位置，所以可以分成9×9×9=729种填充情况，每种情况对应于舞蹈链里十字链表的一行。<br>&emsp;&emsp;对于每一种填充情况，有4个约束：<br>&emsp;&emsp;&emsp;1. 每个位置都要填数字，不能不填。<br>&emsp;&emsp;&emsp;2. 一行不能有重复的数字。<br>&emsp;&emsp;&emsp;3. 一列不能有重复的数字。<br>&emsp;&emsp;&emsp;4. 每个3×3的子矩阵内不能有重复的数字。<br>&emsp;&emsp;第1种约束可以用十字链表的81(9×9个位置)列来对应，如果舞蹈链计算结果所选择的行能覆盖这81列，则说明81个位置都填了数字。第2种约束也用81列来对应，因为共有9行，要保证每行没有重复的数字，只需要每行都填9个不同的数字就行，如果这81列都被覆盖，且没有重复覆盖，就能满足第二个约束了。第3种和第4种约束与第2种类似，都分别用81列来对应。4种约束一共用4×9×9=324列来对应。<br>&emsp;&emsp;729种填充情况里，每选择一种填充情况，都会占用一个9×9里的一个位置，占用9行里某一行的一个数字、9列里某一列的一个数字，9个3×3的子矩阵里的一个数字，所以每种填充情况都会覆盖4列。因为有一部分位置已经被预先填好了，所以已经填了数字的位置和没填数字的位置，需要分开来处理，没有填数字的位置需要枚举填1～9的9种填充情况，每种填充情况将对应的4列加入十字链表了，已经填了的就直接处理对应数字的填充情况就好了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=3074 */</span></span><br><span class="line"><span class="comment">/* AC 372K	63MS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舞蹈链算法，用于求不重复精确覆盖问题 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N * MAX_N * MAX_N;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = MAX_N * MAX_N * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[(MAX_ROWS + <span class="number">1</span>) * MAX_COLS + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_min_ans;</span><br><span class="line">	<span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">int</span> ans, *select_rows;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里移除 */</span></span><br><span class="line">		nd[nd[col].l].r = nd[col].r;</span><br><span class="line">		nd[nd[col].r].l = nd[col].l;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行移除 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = nd[j].d;</span><br><span class="line">				nd[nd[j].d].u = nd[j].u;</span><br><span class="line">				col_nds[nd[j].col]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里恢复 */</span></span><br><span class="line">		nd[nd[col].l].r = col;</span><br><span class="line">		nd[nd[col].r].l = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行恢复 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = j;</span><br><span class="line">				nd[nd[j].d].u = j;</span><br><span class="line">				col_nds[nd[j].col]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断是否超过了界限 */</span></span><br><span class="line">		<span class="keyword">if</span>(limit != <span class="number">-1</span> &amp;&amp; len &gt; limit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_min_ans == <span class="literal">true</span> &amp;&amp; ans != <span class="number">-1</span> &amp;&amp; len &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		remove(select_col);</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(select_rows != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[len] = nd[i].row;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is_min_ans == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; res)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		resume(select_col);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> is_min_ans = <span class="literal">true</span>, <span class="keyword">int</span> select_rows[] = <span class="number">0</span>, <span class="keyword">int</span> limit = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;is_min_ans = is_min_ans;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		<span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		ans = dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link;</span><br><span class="line"></span><br><span class="line">dance_link dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, len, r, c, row;</span><br><span class="line">	<span class="keyword">int</span> x[dl.MAX_ROWS], y[dl.MAX_ROWS], num[dl.MAX_ROWS], ans[dl.MAX_ROWS], ansl;</span><br><span class="line">	<span class="keyword">char</span> str[MAX_N * MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(fgets(str, MAX_N * MAX_N, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str[i] = str[i] - <span class="string">'0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				k = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// printf("%d ", str[i]);</span></span><br><span class="line">			<span class="comment">// if((i + 1) % 9 == 0)</span></span><br><span class="line">			<span class="comment">// &#123;</span></span><br><span class="line">			<span class="comment">// 	printf("\n");</span></span><br><span class="line">			<span class="comment">// &#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// printf("\n");</span></span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dl.init(<span class="number">9</span> * <span class="number">9</span> * <span class="number">9</span>, <span class="number">4</span> * <span class="number">9</span> * <span class="number">9</span>);</span><br><span class="line">		row = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			r = i / <span class="number">9</span>;</span><br><span class="line">			c = i % <span class="number">9</span>;</span><br><span class="line">			<span class="keyword">if</span>(str[i] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					dl.add_node(row, r * <span class="number">9</span> + c + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">81</span> + r * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">162</span> + c * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">243</span> + (r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>) * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">					x[row] = r;</span><br><span class="line">					y[row] = c;</span><br><span class="line">					num[row] = k + <span class="number">1</span>;</span><br><span class="line">					row++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				k = str[i] - <span class="number">1</span>;</span><br><span class="line">				dl.add_node(row, r * <span class="number">9</span> + c + <span class="number">1</span>);</span><br><span class="line">				dl.add_node(row, <span class="number">81</span> + r * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">				dl.add_node(row, <span class="number">162</span> + c * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">				dl.add_node(row, <span class="number">243</span> + (r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>) * <span class="number">9</span> + k + <span class="number">1</span>);</span><br><span class="line">				x[row] = r;</span><br><span class="line">				y[row] = c;</span><br><span class="line">				num[row] = k + <span class="number">1</span>;</span><br><span class="line">				row++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ansl = dl.solve(<span class="literal">false</span>, ans);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ansl; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			r = x[ans[i]];</span><br><span class="line">			c = y[ans[i]];</span><br><span class="line">			k = num[ans[i]];</span><br><span class="line">			str[r * <span class="number">9</span> + c] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// for(i = 0; i &lt; 81; i++)</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	printf("%d ", str[i]);</span></span><br><span class="line">		<span class="comment">// 	if((i + 1) % 9 == 0)</span></span><br><span class="line">		<span class="comment">// 	&#123;</span></span><br><span class="line">		<span class="comment">// 		printf("\n");</span></span><br><span class="line">		<span class="comment">// 	&#125;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// printf("\n");</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, str[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.</span></span><br><span class="line"><span class="comment">......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ_1236 Network of Schools</title>
    <url>/acm/poj_1236/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1236" target="_blank" rel="noopener">http://poj.org/problem?id=1236</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;有N个学校用一些单向的网络连接一起，每个学校得到一套软件后，可以通过单向网络向周边的学校传输。<br>&emsp;&emsp;问题1：初始至少需要向多少个学校发放软件，使得网络内所有的学校最终都能得到软件。<br>&emsp;&emsp;问题2：至少需要添加几条传输线路，使任意向一个学校发放软件后，经过若干次传送，网络内所有的学校最终都能得到软件。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;将学校当做点，网络线路当做边，得到一个有向图，算出这个图里所有的强连通分量。因为同一个强连通分量之间的任意两点可以互相连通，所以向一个点发送软件后，与这个点同属于一个强连通分量的点都能收到软件。可以将每个强连通分量都假设为一个点，然后算出所有强连通分量的入度和出度，假设入度为0的强连通分量的个数为d_in0，出度为0的强连通分量的个数为d_out0。问题1的答案等于d_in0；当强连通分量的个数为1时，问题2的答案等于0，当强连通分量的个数大于1时，问题2的答案等于max(d_in0, d_out0)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AC 0MS 356K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> vis[MAX_N], <span class="keyword">vis_t</span>;</span><br><span class="line"><span class="keyword">int</span> st[MAX_N], st_top;</span><br><span class="line"><span class="keyword">int</span> in_st[MAX_N];</span><br><span class="line"><span class="keyword">int</span> low[MAX_N];</span><br><span class="line"><span class="keyword">int</span> belong[MAX_N], ccn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k;</span><br><span class="line"></span><br><span class="line">	vis[v] = <span class="keyword">vis_t</span>;</span><br><span class="line">	low[v] = <span class="keyword">vis_t</span>;</span><br><span class="line">	<span class="keyword">vis_t</span>++;</span><br><span class="line">	st_top++;</span><br><span class="line">	st[st_top] = v;</span><br><span class="line">	in_st[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[v][i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tarjan(i);</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt; low[i])</span><br><span class="line">			&#123;</span><br><span class="line">				low[v] = low[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(in_st[i] == <span class="number">1</span> &amp;&amp; low[v] &gt; vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			low[v] = vis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[v] == vis[v])</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k != v)</span><br><span class="line">		&#123;</span><br><span class="line">			k = st[st_top];</span><br><span class="line">			st_top--;</span><br><span class="line">			in_st[k] = <span class="number">0</span>;</span><br><span class="line">			belong[k] = ccn;</span><br><span class="line">		&#125;</span><br><span class="line">		ccn++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> d_in0, d_out0;</span><br><span class="line">	<span class="keyword">int</span> d_in[MAX_N], d_out[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) != EOF &amp;&amp; k !=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mp[i][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算强连通分量 */</span></span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(in_st, <span class="number">0</span>, <span class="keyword">sizeof</span>(in_st));</span><br><span class="line">	ccn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st_top = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">vis_t</span> = <span class="number">1</span>;</span><br><span class="line">			tarjan(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算每个强连通分量的入度和出度 */</span></span><br><span class="line">	<span class="built_in">memset</span>(d_in, <span class="number">0</span>, <span class="keyword">sizeof</span>(d_in));</span><br><span class="line">	<span class="built_in">memset</span>(d_out, <span class="number">0</span>, <span class="keyword">sizeof</span>(d_out));</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j] == <span class="number">1</span> &amp;&amp; belong[i] != belong[j])</span><br><span class="line">			&#123;</span><br><span class="line">				d_in[belong[j]]++;</span><br><span class="line">				d_out[belong[i]]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d_in0 = <span class="number">0</span>;</span><br><span class="line">	d_out0 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ccn; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d_in[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			d_in0++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(d_out[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			d_out0++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ccn == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1\n0\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, d_in0, (d_in0 &gt; d_out0) ? d_in0 : d_out0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ_1679 The Unique MST</title>
    <url>/acm/poj_1679/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="http://poj.org/problem?id=1679" target="_blank" rel="noopener">http://poj.org/problem?id=1679</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一张无向图，问图的最小生成数是否唯一，不唯一的话输出<code>Not Unique!</code>，否则输出最小生成树的边权和。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;算出图的最小生成树，然后算出次小生成数，判断一下是否相等。（第一次写次小生成树，bug改了好久(T﹏T)！）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* http://poj.org/problem?id=1679 */</span></span><br><span class="line"><span class="comment">/* AC 0MS 412K */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x1f1f1f1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> mst[MAX_N];</span><br><span class="line"><span class="keyword">int</span> maxd[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, min, ans;</span><br><span class="line">	<span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = mp[<span class="number">1</span>][i];</span><br><span class="line">		mst[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] != <span class="number">-1</span> &amp;&amp; min &gt; dist[j])</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min == INF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += dist[k];</span><br><span class="line">		dist[k] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] != <span class="number">-1</span> &amp;&amp; dist[j] &gt; mp[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = mp[k][j];</span><br><span class="line">				mst[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dist[j] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> pre = mst[k];</span><br><span class="line">				maxd[j][k] = (maxd[j][pre] &gt; mp[pre][k]) ? maxd[j][pre] : mp[pre][k];</span><br><span class="line">				maxd[k][j] = maxd[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sec_mst</span><span class="params">(<span class="keyword">int</span> mst_l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, ans;</span><br><span class="line"></span><br><span class="line">	ans = INF;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == j || mp[i][j] == INF || mst[i] == j || mst[j] == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans &gt; mst_l + mp[i][j] - maxd[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				ans = mst_l + mp[i][j] - maxd[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans == INF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, i, x, y, w, mst_l;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">		<span class="built_in">memset</span>(maxd, <span class="number">0</span>, <span class="keyword">sizeof</span>(maxd));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			mp[i][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">			<span class="keyword">if</span>(mp[x][y] &gt; w)</span><br><span class="line">			&#123;</span><br><span class="line">				mp[x][y] = w;</span><br><span class="line">				mp[y][x] = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mst_l = prim();</span><br><span class="line">		<span class="keyword">if</span>(mst_l &lt; <span class="number">0</span> || mst_l == sec_mst(mst_l))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mst_l);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>次小生成树</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA-315 Network</title>
    <url>/acm/uva_315/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=251" target="_blank" rel="noopener">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=251</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一张无向图，求图中割点的个数。割点是指删除该点后，其他点之间的连通性会受到影响的点。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;用tarjan算法来解决，这题的输入有点麻烦，因为输入的问题runtime error了好几次。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* https://cn.vjudge.net/contest/67418#problem/B */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (a &lt; b) ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mp[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> vis[MAX_N], vis_n;</span><br><span class="line"><span class="keyword">int</span> low[MAX_N];</span><br><span class="line"><span class="keyword">int</span> is_ctp[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, child = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	vis[v] = vis_n;</span><br><span class="line">	low[v] = vis_n;</span><br><span class="line">	vis_n++;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[v][i] != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[i] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tarjan(i, root);</span><br><span class="line">				low[v] = min(low[v], low[i]);</span><br><span class="line">				<span class="keyword">if</span>(v == root)</span><br><span class="line">				&#123;</span><br><span class="line">					child++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(low[i] &gt;= vis[v])</span><br><span class="line">				&#123;</span><br><span class="line">					is_ctp[v] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				low[v] = min(low[v], vis[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(v == root &amp;&amp; child &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		is_ctp[root] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, a, b, ans;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a) != EOF &amp;&amp; a != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">				mp[a][b] = <span class="number">1</span>;</span><br><span class="line">				mp[b][a] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(is_ctp, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_ctp));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[i] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis_n = <span class="number">1</span>;</span><br><span class="line">				tarjan(i, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(is_ctp[i] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>tarjan算法</tag>
        <tag>连通图</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA-796 Critical Links</title>
    <url>/acm/uva_796/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=737" target="_blank" rel="noopener">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=737</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出一张无向图，求图的割边。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;大致的思路和求图的割点类似，用tarjan算法解决。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (a &lt; b) ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">&#125; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.a != b.a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, bn;</span><br><span class="line">node e[<span class="number">2</span> * MAX_N * MAX_N];</span><br><span class="line">edge bridge[MAX_N];</span><br><span class="line"><span class="keyword">int</span> head[MAX_N];</span><br><span class="line"><span class="keyword">int</span> vis[MAX_N], v_ind;</span><br><span class="line"><span class="keyword">int</span> low[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, b;</span><br><span class="line"></span><br><span class="line">	vis[v] = v_ind;</span><br><span class="line">	low[v] = v_ind;</span><br><span class="line">	v_ind++;</span><br><span class="line">	<span class="keyword">for</span>(i = head[v]; i != <span class="number">-1</span>; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		b = e[i].b;</span><br><span class="line">		<span class="keyword">if</span>(vis[b] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tarjan(b, v);</span><br><span class="line">			low[v] = min(low[v], low[b]);</span><br><span class="line">			<span class="keyword">if</span>(low[b] &gt; vis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(v &lt; b)</span><br><span class="line">				&#123;</span><br><span class="line">					bridge[bn].a = v;</span><br><span class="line">					bridge[bn].b = b;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					bridge[bn].a = b;</span><br><span class="line">					bridge[bn].b = v;</span><br><span class="line">				&#125;</span><br><span class="line">				bn++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b != pre)</span><br><span class="line">		&#123;</span><br><span class="line">			low[v] = min(low[v], vis[b]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, k, b;</span><br><span class="line">	<span class="keyword">int</span> i, j, en;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">		en = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d (%d)"</span>, &amp;a, &amp;k);</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">				e[en].b = b;</span><br><span class="line">				e[en].next = head[a];</span><br><span class="line">				head[a] = en;</span><br><span class="line">				en++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bn = <span class="number">0</span>;</span><br><span class="line">		v_ind = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tarjan(i, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">std</span>::sort(bridge, bridge + bn, cmp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d critical links\n"</span>, bn);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d - %d\n"</span>, bridge[i].a, bridge[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>tarjan算法</tag>
        <tag>连通图</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ-1017 Treasure Map</title>
    <url>/acm/zoj-1017/</url>
    <content><![CDATA[<p>二维精确覆盖问题</p>
<a id="more"></a>


<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367871" target="_blank" rel="noopener">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367871</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给出p个小矩形和每个小矩形的左下角、右上角坐标，问能否用这些小矩形拼成一个m×n的大矩形，拼接的时候小矩形的位置不能改变，且小矩形之间不能重叠。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这是一个二维的精确覆盖问题，可以转化为一维来处理。对于每一个小矩形，将其能覆盖的区域赋值为1，不能覆盖的区域赋值为0，这样就构建了一个m×n的矩阵，然后将这个二维的矩阵转化为一维的向量。转化的方法就是，把矩阵的m行元素按顺利排一行，比如矩阵的第一行的第1、2、…、n-1、n个元素的作为向量的第1、2、…、n-1、n个元素，第二行的第1、2、…、n-1、n个元素作为向量的第n+1、n+2、….、2n-1、2n个元素，第i行的第j个元素的作为第i×n+j元素。接下来将p个小矩形转化成的p个向量组成一个p行m×n列的的矩阵，这样题目就转化为对这个矩阵求标准的精确覆盖问题，用舞蹈链算法处理一下就好了。<br>&emsp;&emsp;需要注意的是，这题需要求覆盖整个大矩形，最少使用的小矩形，求出可行解后需要继续搜索出最优解。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367871 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_COLS = <span class="number">30</span> * <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_ROWS = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">	<span class="keyword">int</span> row, col;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">node nd[MAX_ROWS * MAX_COLS];</span><br><span class="line"><span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		nd[i].u = i;</span><br><span class="line">		nd[i].d = i;</span><br><span class="line">		nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">		nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nd[<span class="number">0</span>].l = cols;</span><br><span class="line">	nd[cols].r = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(col_nds, <span class="number">0</span>, <span class="keyword">sizeof</span>(col_nds));</span><br><span class="line">	node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">	<span class="built_in">memset</span>(row_head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(row_head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">	nd[node_size].row = row;</span><br><span class="line">	nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">	nd[node_size].u = col;</span><br><span class="line">	nd[node_size].d = nd[col].d;</span><br><span class="line">	nd[nd[col].d].u = node_size;</span><br><span class="line">	nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">	<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		row_head[row] = node_size;</span><br><span class="line">		nd[node_size].l = node_size;</span><br><span class="line">		nd[node_size].r = node_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">		nd[node_size].r = row_first;</span><br><span class="line">		nd[node_size].l = nd[row_first].l;</span><br><span class="line">		nd[nd[row_first].l].r = node_size;</span><br><span class="line">		nd[row_first].l = node_size;</span><br><span class="line">	&#125;</span><br><span class="line">	col_nds[col]++;</span><br><span class="line">	node_size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将第col列从十字链表里移除 */</span></span><br><span class="line">	nd[nd[col].l].r = nd[col].r;</span><br><span class="line">	nd[nd[col].r].l = nd[col].l;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将与第col列里节点有关的行移除 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[j].u].d = nd[j].d;</span><br><span class="line">			nd[nd[j].d].u = nd[j].u;</span><br><span class="line">			col_nds[nd[j].col]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将第col列从十字链表里恢复 */</span></span><br><span class="line">	nd[nd[col].l].r = col;</span><br><span class="line">	nd[nd[col].r].l = col;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将与第col列里节点有关的行恢复 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[nd[j].u].d = j;</span><br><span class="line">			nd[nd[j].d].u = j;</span><br><span class="line">			col_nds[nd[j].col]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, res, select_col;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt;= ans)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">	<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = len;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	min = MAX_ROWS;</span><br><span class="line">	<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min &gt; col_nds[i])</span><br><span class="line">		&#123;</span><br><span class="line">			select_col = i;</span><br><span class="line">			min = col_nds[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	remove(select_col);</span><br><span class="line">	<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">		&#123;</span><br><span class="line">			remove(nd[j].col);</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(len + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">		&#123;</span><br><span class="line">			resume(nd[j].col);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	resume(select_col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, n, m, p, x1, x2, y1, y2;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, len;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">		rows = p;</span><br><span class="line">		cols = n * m;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; p; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">			<span class="keyword">for</span>(i = y1; i &lt; y2; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j = x1; j &lt; x2; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					add_node(k + <span class="number">1</span>, i * n + j + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = MAX_ROWS;</span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(ans == MAX_ROWS)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ-3122 Sudoku</title>
    <url>/acm/zoj-3122/</url>
    <content><![CDATA[<p>用舞蹈链来解决16×16数独问题</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367537" target="_blank" rel="noopener">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367537</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;给一个16×16的矩阵，求解数独问题。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>&emsp;&emsp;这题跟上一题的解法类似，只是上一题是9×9，这题是16×16，具体请参考<a href="https://nchuxw.github.io/post/poj-3074-sudoku/" target="_blank" rel="noopener">https://nchuxw.github.io/post/poj-3074-sudoku/</a>，题目的测试样例的输入有问题，需要改正，还有就是输出的时候最后一个测试样例不要换行，否则会<code>Presentation Error</code>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367537 */</span></span><br><span class="line"><span class="comment">/* AC 201ms	640kb */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舞蹈链算法，用于求不重复精确覆盖问题 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dance_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ROWS = MAX_N * MAX_N * MAX_N + <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_COLS = MAX_N * MAX_N * <span class="number">4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u, d, l, r;</span><br><span class="line">		<span class="keyword">int</span> row, col;</span><br><span class="line">	&#125; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows, cols, node_size;</span><br><span class="line">	node nd[(MAX_ROWS + <span class="number">1</span>) * MAX_COLS];</span><br><span class="line">	<span class="keyword">int</span> row_head[MAX_ROWS], col_nds[MAX_COLS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_min_ans;</span><br><span class="line">	<span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">int</span> ans, *select_rows;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; rows = rows;</span><br><span class="line">		<span class="keyword">this</span> -&gt; cols = cols;</span><br><span class="line">		<span class="comment">/* 初始化每一列的头节点 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= cols; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nd[i].u = i;</span><br><span class="line">			nd[i].d = i;</span><br><span class="line">			nd[i].l = i - <span class="number">1</span>;</span><br><span class="line">			nd[i].r = i + <span class="number">1</span>;</span><br><span class="line">			col_nds[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nd[<span class="number">0</span>].l = cols;</span><br><span class="line">		nd[cols].r = <span class="number">0</span>;</span><br><span class="line">		node_size = cols + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化每一行的行指针 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* nd[node_size]为新添加的节点 */</span></span><br><span class="line">		nd[node_size].row = row;</span><br><span class="line">		nd[node_size].col = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的列连接 */</span></span><br><span class="line">		nd[node_size].u = col;</span><br><span class="line">		nd[node_size].d = nd[col].d;</span><br><span class="line">		nd[nd[col].d].u = node_size;</span><br><span class="line">		nd[col].d = node_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新添加的节点与其所在的行连接 */</span></span><br><span class="line">		<span class="keyword">if</span>(row_head[row] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			row_head[row] = node_size;</span><br><span class="line">			nd[node_size].l = node_size;</span><br><span class="line">			nd[node_size].r = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> row_first = row_head[row];</span><br><span class="line">			nd[node_size].r = row_first;</span><br><span class="line">			nd[node_size].l = nd[row_first].l;</span><br><span class="line">			nd[nd[row_first].l].r = node_size;</span><br><span class="line">			nd[row_first].l = node_size;</span><br><span class="line">		&#125;</span><br><span class="line">		col_nds[col]++;</span><br><span class="line">		node_size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里移除 */</span></span><br><span class="line">		nd[nd[col].l].r = nd[col].r;</span><br><span class="line">		nd[nd[col].r].l = nd[col].l;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行移除 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = nd[j].d;</span><br><span class="line">				nd[nd[j].d].u = nd[j].u;</span><br><span class="line">				col_nds[nd[j].col]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将第col列从十字链表里恢复 */</span></span><br><span class="line">		nd[nd[col].l].r = col;</span><br><span class="line">		nd[nd[col].r].l = col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将与第col列里节点有关的行恢复 */</span></span><br><span class="line">		<span class="keyword">for</span>(i = nd[col].d; i != col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				nd[nd[j].u].d = j;</span><br><span class="line">				nd[nd[j].d].u = j;</span><br><span class="line">				col_nds[nd[j].col]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> res, select_col;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断是否超过了界限 */</span></span><br><span class="line">		<span class="keyword">if</span>(limit != <span class="number">-1</span> &amp;&amp; len &gt; limit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_min_ans == <span class="literal">true</span> &amp;&amp; ans != <span class="number">-1</span> &amp;&amp; len &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 当前十字链表没有列 */</span></span><br><span class="line">		<span class="keyword">if</span>(nd[<span class="number">0</span>].r == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">		select_col = nd[<span class="number">0</span>].r;</span><br><span class="line">		<span class="keyword">for</span>(i = nd[<span class="number">0</span>].r; i != <span class="number">0</span>; i = nd[i].r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nd[i].d == i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(col_nds[select_col] &gt; col_nds[i])</span><br><span class="line">			&#123;</span><br><span class="line">				select_col = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		remove(select_col);</span><br><span class="line">		<span class="keyword">for</span>(i = nd[select_col].d; i != select_col; i = nd[i].d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(select_rows != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				select_rows[len] = nd[i].row;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].r; j != i; j = nd[j].r)</span><br><span class="line">			&#123;</span><br><span class="line">				remove(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">			res = dfs(len + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is_min_ans == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> res;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; res)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = res;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j = nd[i].l; j != i; j = nd[j].l)</span><br><span class="line">			&#123;</span><br><span class="line">				resume(nd[j].col);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		resume(select_col);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool is_min_ans: 是否求答案最小值，如果不是，得到一个可行解就返回，默认求最小值。</span></span><br><span class="line"><span class="comment">	int select_rows[]: 用于保存选择的行，取NULL时不保存，默认取NULL。</span></span><br><span class="line"><span class="comment">	int limit：答案的上限，取-1时无上限，默认为-1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> is_min_ans = <span class="literal">true</span>, <span class="keyword">int</span> select_rows[] = <span class="number">0</span>, <span class="keyword">int</span> limit = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;is_min_ans = is_min_ans;</span><br><span class="line">		<span class="keyword">this</span>-&gt;select_rows = select_rows;</span><br><span class="line">		<span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">		ans = <span class="number">-1</span>;</span><br><span class="line">		ans = dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; dance_link;</span><br><span class="line"></span><br><span class="line">dance_link dl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, t, row;</span><br><span class="line">	<span class="keyword">char</span> str[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> x[dl.MAX_ROWS], y[dl.MAX_ROWS], num[dl.MAX_ROWS], ans[dl.MAX_ROWS], ansl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(t = <span class="number">0</span>; ; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]) == EOF)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; <span class="number">16</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(t != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dl.init(<span class="number">16</span> * <span class="number">16</span> * <span class="number">16</span>, <span class="number">4</span> * <span class="number">16</span> * <span class="number">16</span>);</span><br><span class="line">		row = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">'A'</span> &lt;= str[i][j] &amp;&amp; str[i][j] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					k = (<span class="keyword">int</span>)(str[i][j] - <span class="string">'A'</span>);</span><br><span class="line">					dl.add_node(row, i * <span class="number">16</span> + j + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">256</span> + i * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">512</span> + j * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">					dl.add_node(row, <span class="number">768</span> + (i / <span class="number">4</span> * <span class="number">4</span> + j / <span class="number">4</span>) * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">					<span class="comment">// printf("(%d,%d) ", row, i * 16 + j + 1);</span></span><br><span class="line">					<span class="comment">// printf("(%d,%d) ", row, 256 + i * 16 + k + 1);</span></span><br><span class="line">					<span class="comment">// printf("(%d,%d) ", row, 512 + j * 16 + k + 1);</span></span><br><span class="line">					<span class="comment">// printf("(%d,%d)\n", row, 768 + (i / 4 * 4 + j / 4) * 16 + k + 1);</span></span><br><span class="line">					x[row] = i;</span><br><span class="line">					y[row] = j;</span><br><span class="line">					num[row] = k;</span><br><span class="line">					row++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(str[i][j] == <span class="string">'-'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">16</span>; k++)</span><br><span class="line">					&#123;</span><br><span class="line">						dl.add_node(row, i * <span class="number">16</span> + j + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">256</span> + i * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">512</span> + j * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">						dl.add_node(row, <span class="number">768</span> + (i / <span class="number">4</span> * <span class="number">4</span> + j / <span class="number">4</span>) * <span class="number">16</span> + k + <span class="number">1</span>);</span><br><span class="line">						<span class="comment">// printf("(%d,%d) ", row, i * 16 + j + 1);</span></span><br><span class="line">						<span class="comment">// printf("(%d,%d) ", row, 256 + i * 16 + k + 1);</span></span><br><span class="line">						<span class="comment">// printf("(%d,%d) ", row, 512 + j * 16 + k + 1);</span></span><br><span class="line">						<span class="comment">// printf("(%d,%d)\n", row, 768 + (i / 4 * 4 + j / 4) * 16 + k + 1);</span></span><br><span class="line">						x[row] = i;</span><br><span class="line">						y[row] = j;</span><br><span class="line">						num[row] = k;</span><br><span class="line">						row++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ansl = dl.solve(<span class="literal">false</span>, ans);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ansl; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			str[x[ans[i]]][y[ans[i]]] = (<span class="keyword">char</span>)(<span class="string">'A'</span> + num[ans[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			str[i][<span class="number">16</span>] = <span class="string">'\0'</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--A----C-----O-I</span></span><br><span class="line"><span class="comment">-J--A-B-P-CGF-H-</span></span><br><span class="line"><span class="comment">--D--F-I-E----P-</span></span><br><span class="line"><span class="comment">-G-EL-H----M-J--</span></span><br><span class="line"><span class="comment">----E----C--G---</span></span><br><span class="line"><span class="comment">-I--K-GA-B---E-J</span></span><br><span class="line"><span class="comment">D-GP--J-F----A--</span></span><br><span class="line"><span class="comment">-E---C-B--DP--O-</span></span><br><span class="line"><span class="comment">E--F-M--D--L-K-A</span></span><br><span class="line"><span class="comment">-C--------O-I-L-</span></span><br><span class="line"><span class="comment">H-P-C--F-A--B---</span></span><br><span class="line"><span class="comment">---G-OD---J----H</span></span><br><span class="line"><span class="comment">K---J----H-A-P-L</span></span><br><span class="line"><span class="comment">--B--P--E--K--A-</span></span><br><span class="line"><span class="comment">-H--B--K--FI-C--</span></span><br><span class="line"><span class="comment">--F---C--D--H-N-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FPAHMJECNLBDKOGI</span></span><br><span class="line"><span class="comment">OJMIANBDPKCGFLHE</span></span><br><span class="line"><span class="comment">LNDKGFOIJEAHMBPC</span></span><br><span class="line"><span class="comment">BGCELKHPOFIMAJDN</span></span><br><span class="line"><span class="comment">MFHBELPOACKJGNID</span></span><br><span class="line"><span class="comment">CILNKDGAHBMOPEFJ</span></span><br><span class="line"><span class="comment">DOGPIHJMFNLECAKB</span></span><br><span class="line"><span class="comment">JEKAFCNBGIDPLHOM</span></span><br><span class="line"><span class="comment">EBOFPMIJDGHLNKCA</span></span><br><span class="line"><span class="comment">NCJDHBAEKMOFIGLP</span></span><br><span class="line"><span class="comment">HMPLCGKFIAENBDJO</span></span><br><span class="line"><span class="comment">AKIGNODLBPJCEFMH</span></span><br><span class="line"><span class="comment">KDEMJIFNCHGAOPBL</span></span><br><span class="line"><span class="comment">GLBCDPMHEONKJIAF</span></span><br><span class="line"><span class="comment">PHNOBALKMJFIDCEG</span></span><br><span class="line"><span class="comment">IAFJOECGLDPBHMNK</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>舞蹈链</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像基础</title>
    <url>/image_processing/base_knowledge/</url>
    <content><![CDATA[<p>一些关于数字图像处理的基本知识</p>
<a id="more"></a>


<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>单色光</strong>：没有颜色的光，单色光的唯一属性是强度。<br><strong>灰度级</strong>：单色光的强度，从黑到白的单色光的度量值范围。<br><strong>灰度图像</strong>：用单色光来表示的图像。</p>
<p>一幅图像可以用一个矩阵来表示，矩阵中某个元素表示图像在该点的像素，可以是灰度值或RGB值等。<br><strong>空间域</strong>：一幅数字图像的坐标张成的实平面部分。<br><strong>像素</strong>：图像矩阵中的元素，也可以称之为图像单元或图像元素。</p>
<p><strong>噪声</strong>：存在于图像数据中的不必要的或多余的干扰信息。<br><strong>对比度</strong>：图像中最高和最低灰度级间的灰度差。<br><strong>饱和度</strong>：指图像色彩的纯净程度。</p>
<p><strong>空间分辨率</strong>：用来度量图像中可辨别的最小细节，，通常用单位距离的线对数或单位距离的点数（像素数）来衡量。<br><strong>dpi</strong>：每英寸点数，通常作为单位距离点数的单位。<br><strong>灰度分辨率</strong>：指灰度级中可分辨的最小变化，用于量化灰度的比特数。例如，通常说一幅被量化为256级的图像有8比特的灰度分辨率。</p>
<h1 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h1><h2 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h2><p>&emsp;&emsp;<strong>4邻域</strong>：与像素相邻的四个水平和垂直的相邻像素，坐标为$(x,y)$的像素的4邻域坐标为$(x+1,y)、(x-1,y)、(x,y+1)、(x,y-1)$，像素点p的4邻域可以用$N_4(p)$表示。<br>&emsp;&emsp;<strong>D邻域</strong>：与像素相邻的四个对角相邻像素，坐标为$(x,y)$的像素的D邻域坐标为$(x-1,y-1)、(x-1,y+1)、(x+1,y-1)、(x+1,y+1)$，像素点p的4邻域可以用$N_D(p)$表示。<br>&emsp;&emsp;<strong>8邻域</strong>：由像素的4邻域和D邻域组成。像素点p的8邻域可以用$N_8(p)$表示。<br>&emsp;&emsp;位于图像边界的像素点的4邻域、D邻域和8邻域会落入图像的外部。</p>
<h2 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h2><p>&emsp;&emsp;令$V$是定义邻接的灰度值集合，假设像素$p$和$q$的像素值在集合$V$中，像素$p$和$q$的4邻接、8邻接和m邻接定义如下<br>&emsp;&emsp;<strong>4邻接</strong>：如果$q$在$p$的4邻域中，则$p$和$q$是4邻接的。<br>&emsp;&emsp;<strong>8邻接</strong>：如果$q$在$p$的8邻域中，则$p$和$q$是8邻接的。<br>&emsp;&emsp;<strong>m邻接</strong>：如果像素$p$和$q$满足以下两个条件之一，则$p$和$q$是m邻接的。<br>&emsp;&emsp;&emsp;&emsp; 1. $q$在$p$的4邻域中。<br>&emsp;&emsp;&emsp;&emsp; 2. $q$在$p$的D邻域中，且$p$和$q$的4邻域交集中没有没有来自$V$中数值的像素。<br>&emsp;&emsp;m邻接也叫混合邻接，m邻接是8邻接的改进，目的是消除8邻接带来的对角相邻像素之间可能产生的多余的斜向路径。</p>
<h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><p>&emsp;&emsp;<strong>通路</strong>：像素$p$到像素$q$之间的通路是由不同像素组成的一个序列，序列中左右相邻的两个像素之间都是邻接的。可根据不同的邻接类型（4邻接、8邻接、m邻接）定义不同的通路类型（4通路、8通路、m通路），其中8通路可能不唯一。<br>&emsp;&emsp;<strong>连通</strong>：令$S$是图像中的一个像素子集（图像中像素点组成的集合）。如果两个像素$p$和$q$之间存在一条完全由$S$中的像素构成的通路（像素$p$和$q$均在$S$中），那么称像素$p$和$q$在$S$中连通。<br>&emsp;&emsp;<strong>连通分量</strong>：对于$S$中的任意一个像素$p$，在$S$中与像素$p$连通的像素构成的像素集合称为$S$的连通分量。<br>&emsp;&emsp;<strong>连通集</strong>：如果$S$仅有一个连通分量，即$S$中的所有像素互相都连通，则$S$称为连通集。</p>
<h2 id="区域和边界"><a href="#区域和边界" class="headerlink" title="区域和边界"></a>区域和边界</h2><p>&emsp;&emsp;<strong>区域</strong>：令$R$是图像中的一个像素子集，如果$R$是一个连通集，则称$R$为图像的一个区域。<br>&emsp;&emsp;<strong>邻接区域</strong>：两个区域$R_i$和$R_j$，如果将他们合并后能够形成一个连通集，则称区域$R_i$和$R_j$为邻接区域。不邻接的区域称为不邻接区域。<br>&emsp;&emsp;<strong>边界</strong>：区域$R$的边界（也叫边框或者轮廓）是区域$R$中与$R$的补集邻接的像素点组成的集合。<br>&emsp;&emsp;假设一幅图像中含有$K$个不邻接的区域$R_k,k=1,2,…,K$，且这些区域都不接触图像的边界。令$Ru$表示这$K$个区域的并集，$(Ru)c$表示$Ru$的补集，那么$Ru$称中的所有像素点为图像的前景，$(Ru)c$中的所有像素点为图像的背景。<br>&emsp;&emsp;上述边界的定义有时称为区域的<strong>内边界</strong>，即边界像素是在区域内部。与内边界相区分的是<strong>外边界</strong>，即边界像素在背景区域内。</p>
<h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>&emsp;&emsp;设像素点$p$的坐标为$(x_p,y_p)$，$q$的坐标为$(x_q,y_q)$，则$p$和$q$之间的三种距离定义如下。<br>&emsp;&emsp;<strong>欧式距离</strong>：用$D_e(p,q)$来表示。<br>$$D_e(p,q) = \sqrt{(x_p - x_q)^2 + (y_p - y_q)^2}$$</p>
<p>&emsp;&emsp;在欧式距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素都在以$(x,y)$为中心、半径为$r$的圆形区域内。</p>
<p>&emsp;&emsp;<strong>城市距离</strong>：用$D_4(p,q)$来表示。<br>$$D_4(p,q) = |x_p - x_q| + |y_p - y_q|$$</p>
<p>&emsp;&emsp;在城市距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素形成一个以$(x,y)$为中心的菱形区域。</p>
<p>&emsp;&emsp;<strong>棋盘距离</strong>：用$D_8(p,q)$来表示。<br>$$D_8(p,q) = max(|x_p - x_q|,|y_p - y_q|)$$</p>
<p>&emsp;&emsp;在棋盘距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素形成一个以$(x,y)$为中心的方形区域。</p>
<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="阵列与矩阵操作"><a href="#阵列与矩阵操作" class="headerlink" title="阵列与矩阵操作"></a>阵列与矩阵操作</h2><p>&emsp;&emsp;<strong>阵列操作</strong>：对图像矩阵中每个像素进行操作，比如对图像阵列进行求幂操作，表示对图像矩阵中每个像素都进行求幂。<br>&emsp;&emsp;<strong>矩阵操作</strong>：对图像矩阵进行矩阵的操作，矩阵的操作请参考线性代数里的介绍。<br>&emsp;&emsp;矩阵操作的乘法和阵列操作的乘法不同。<br>&emsp;&emsp;阵列操作的乘法：<br>$$<br>\left[\begin{matrix}<br>    a_{11} &amp; a_{12} \\<br>    a_{21} &amp; a_{22} \\<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>    b_{11} &amp; b_{12} \\<br>    b_{21} &amp; b_{22} \\<br>\end{matrix}\right] =<br>\left[\begin{matrix}<br>    a_{11}b_{11} &amp; a_{12}b_{12} \\<br>    a_{21}b_{21} &amp; a_{22}b_{22} \\<br>\end{matrix}\right]<br>$$</p>
<p>&emsp;&emsp;矩阵操作的乘法：<br>$$<br>\left[\begin{matrix}<br>    a_{11} &amp; a_{12} \\<br>    a_{21} &amp; a_{22} \\<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>    b_{11} &amp; b_{12} \\<br>    b_{21} &amp; b_{22} \\<br>\end{matrix}\right] =<br>\left[\begin{matrix}<br>    a_{11}b_{11} + a_{12}b_{21} &amp; a_{11}b_{12} + a_{12}b_{22} \\<br>    a_{21}b_{11} + a_{22}b_{21} &amp; a_{21}b_{12} + a_{22}b_{22} \\<br>\end{matrix}\right]<br>$$</p>
<h2 id="线性操作"><a href="#线性操作" class="headerlink" title="线性操作"></a>线性操作</h2><p>&emsp;&emsp;图像处理方法最重要的分类依据之一是，它是线性的还是非线性的。考虑一般的算子$H$，该算子对于给定的输入图像$f(x,y)$，产生一幅输出图像$g(x,y)$：<br>$$H[f(x, y)] = g(x, y)$$</p>
<p>&emsp;&emsp;<strong>加性</strong>：对两个输入的和进行操作得到的输出，与分别对两个输入进行操作后的输出求和得到的结果相同，用公式可表示为：<br>$$H[f_i(x, y) + f_j(x, y)] = H[f_i(x, y)] + H[f_i(x, y)]$$</p>
<p>&emsp;&emsp;<strong>同质性</strong>：输入乘以一个常数的输出，与原始输入的输出再乘以该常数的结果相同，用公式可表示为：<br>$$H[a \times f(x, y)] = a \times H[f(x, y)]$$</p>
<p>&emsp;&emsp;<strong>线性操作</strong>：同时满足加性和同质性的操作，线性操作的算子成为线性算子，如果$H$是一个线性算子，则需要满足：<br>$$H[a_if_i(x, y) + a_jf_j(x, y)] = a_iH[f_i(x, y)] + a_jH[f_j(x, y)] = a_ig_i(x, y) + a_jg_j(x, y)$$</p>
<p>&emsp;&emsp;上式中，$a_i$和$a_j$是任意常数，$f_i(x, y)$和$f_j(x, y)$是任意大小相同的图像。</p>
<h2 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h2><p>&emsp;&emsp;图像间的算术操作是在相应的像素对之间执行的，属于阵列操作，4种算术操作（即像素间加减乘除）表示为：<br>$$<br>s(x, y) = f(x, y) + g(x, y) \\<br>d(x, y) = f(x, y) - g(x, y) \\<br>p(x, y) = f(x, y) \times g(x, y) \\<br>v(x, y) = f(x, y) \div g(x, y)<br>$$</p>
<p>&emsp;&emsp;上式中$f$和$g$是两张大小相同的图像，计算得到的$s$、$d$、$p$和$v$也是和$f$、$g$大小相同的图像。<br>&emsp;&emsp;<strong>图像相加</strong>后取平均值可以降低图像的噪声。在天文学邻域，由于在非常低的光照下成像常常会导致传感器噪声，以至于单幅图像无法分析。一种降低噪声的方法是对同一个区域（比如某个星系）进行长时间观测，采集多张图片，然后将这多张图像进行算术相加再取平均值，最后得到的图像相比于单张图像会清晰很多。<br>&emsp;&emsp;<strong>图像相减</strong>可以增强两幅近似图像之间的差别，比如观测某一区域的变化过程，可以用采集的图像与第一次采集的图像相减，以增强两幅图像变化比较明显的部分，降低变化比较小的部分。<br>&emsp;&emsp;<strong>图像相乘</strong>的一个重要应用是矫正阴影（这个没看懂T﹏T）。也用来进行模板操作。</p>
<h2 id="空间操作"><a href="#空间操作" class="headerlink" title="空间操作"></a>空间操作</h2><p>&emsp;&emsp;空间操作直接在给定图像的像素上执行。</p>
<h3 id="单像素操作"><a href="#单像素操作" class="headerlink" title="单像素操作"></a>单像素操作</h3><p>&emsp;&emsp;单像素操作生成的图像，每个像素是根据原图中相应像素计算得到的。用公式表示是：<br>$$g(x, y) = T[f(x, y)]$$</p>
<p>&emsp;&emsp;$f(x, y)$表示原图在$(x, y)$处的像素，$T$表示像素的映射函数，$g(x, y)$表示生产图像对应位置的像素。</p>
<h3 id="领域操作"><a href="#领域操作" class="headerlink" title="领域操作"></a>领域操作</h3><p>&emsp;&emsp;领域操作生成的图像，每个像素是根据原图中相应像素的领域计算得到的。用公式表示是：<br>$$g(x, y) = T[N(f(x, y))]$$</p>
<p>&emsp;&emsp;$N(f(x, y))$表示图像在$(x, y)$处的领域。</p>
<h3 id="几何空间变换"><a href="#几何空间变换" class="headerlink" title="几何空间变换"></a>几何空间变换</h3><p>&emsp;&emsp;请参考我的另一篇博客<a href="/image_processing/space_transformation/">图像的几何空间变换</a>。</p>
<h3 id="图像配准"><a href="#图像配准" class="headerlink" title="图像配准"></a>图像配准</h3><p>&emsp;&emsp;图像几何空间变换利用已知的变换函数，将原图像上的像素映射到目标图像上指定的位置。而图像的配准则是根据原图像和目标图像上某些像素点之间的映射关系，求变换函数。具体的做法是假设变换函数的模型，然后在原图像上取一些点，将这些点的坐标和它们映射在目标图像上对应点的坐标，代入变换函数模型中，求解出变换函数的未知参数，最终得到变换函数。<br>&emsp;&emsp;举个栗子，假设目标图像是原图像通过仿射变换生成的，变换方式如下：<br>$$<br>\left[\begin{matrix} x &amp; y &amp; 1 \end{matrix}\right] =<br>\left[\begin{matrix} v &amp; w &amp; 1 \end{matrix}\right]T =<br>\left[\begin{matrix} v &amp; w &amp; 1 \end{matrix}\right]<br>\left[\begin{matrix}<br>t_{11} &amp; t_{12} &amp; 0 \\<br>t_{21} &amp; t_{22} &amp; 0 \\<br>t_{31} &amp; t_{32} &amp; 1<br>\end{matrix}\right]<br>$$</p>
<p>&emsp;&emsp;根据这个变换函数可以列出以下两个方程，这个两个方程就是变换函数的模型。<br>$$<br>x = t_{11}v + t_{21}w + t_{31} \\<br>y = t_{12}v + t_{22}w + t_{32}<br>$$</p>
<p>&emsp;&emsp;然后取原图像上的三个点$(v_1, w_1)$、$(v_2, w_2)$、$(v_3, w_3)$，假设它们在目标图像上对应点的坐标分别是$(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$，将这六个点的坐标值代入变换函数模型中，可以的到两个三元一次方程组：<br>$$<br>\begin{cases}<br>    x_1 = t_{11}v_1 + t_{21}w_1 + t_{31} \\<br>    x_2 = t_{11}v_2 + t_{21}w_2 + t_{31} \\<br>    x_3 = t_{11}v_3 + t_{21}w_3 + t_{31}<br>\end{cases} \ \ \ \ \ \ \<br>\begin{cases}<br>    y_1 = t_{12}v_1 + t_{22}w_1 + t_{32} \\<br>    y_2 = t_{12}v_2 + t_{22}w_2 + t_{32} \\<br>    y_3 = t_{12}v_3 + t_{22}w_3 + t_{32}<br>\end{cases}<br>$$</p>
<p>&emsp;&emsp;解出这两个方程组就可以算出$t_{11}、t_{12}、t_{21}、t_{22}、t_{31}、t_{32}$这几个参数，代入模型中就是我们要求的变换函数了。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的灰度变换</title>
    <url>/image_processing/gray_transformation/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;灰度变换是所有图像处理技术中最简单的技术，输出图像在点$(x, y)$处的像素值仅取决于原图在点$(x, y)$处的像素值。可以用公式$s = T(r)$表示，$r$和$s$分别表示处理前后的像素值，$T$是把像素值$r$映射到像素值$s$的一种变换。<br>&emsp;&emsp;因为处理的是数字量，所以变换函数的值通常存储在一个一维阵列里，从$r$到$s$的映射是通过查表实现的。对于8位的灰度图，$T$包含256个灰度值的映射。<br>&emsp;&emsp;图像增强常用的三类变换函数是：线性变换、对数变换、幂律变换。</p>
<h1 id="反转变换"><a href="#反转变换" class="headerlink" title="反转变换"></a>反转变换</h1><p>&emsp;&emsp;这个比较简单，对于一张灰度级范围为[0, L - 1]的图像，$s$就等于$L - 1 - r$，用公式表示是：$s = L - r$。<br>&emsp;&emsp;使用这种变换方式可以反转一幅图像的灰度值，得到类似照片底片的效果。</p>
<h1 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h1><p>&emsp;&emsp;对数变换的通用公式为：<br>$$ s = c\log(1 + r) $$</p>
<p>&emsp;&emsp;式中$c$是常数，并假设$r&gt;=0$。对数变换和反对数变换的曲线如下所示，蓝色曲线代表对数变换，橙色曲线代表反对数变换（图上反对数变换的公式有点看不清，是$s=e^{\frac{r}{c}} - 1$），c的取值为$\frac{L - 1}{T(L - 1)}$。对数变换将输入中范围较窄的低灰度值映射为输出中范围较宽的灰度值，将输入中范围较宽的高灰度值映射为输出中范围较窄的灰度值。使用这种类型的变换来扩展图像中的暗像素值，同时压缩更高灰度级的值。反对数变换的作用则相反。<br><img src="/images/image_processing/gray_transformation/logarithmic_transformation.png" alt="" title="对数变换和反对数变换"></p>
<h1 id="幂律变换"><a href="#幂律变换" class="headerlink" title="幂律变换"></a>幂律变换</h1><p>&emsp;&emsp;幂律变换也叫伽马变换，它的通用公式为：<br>$$ s = cr^{\gamma} $$</p>
<p>&emsp;&emsp;式中$c$和$\gamma$是常数。不同$\gamma$值的幂律变换曲线如下所示。<br><img src="/images/image_processing/gray_transformation/exponential_transform.png" alt="" title="幂律变换"></p>
<h1 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h1><p>&emsp;&emsp;分段线性变换函数和名字描述的一样，就是按照不同的范围段，用线性函数进行变换。其优点是形式可以任意复杂，缺点是函数要人为调整。</p>
<h2 id="对比度拉伸"><a href="#对比度拉伸" class="headerlink" title="对比度拉伸"></a>对比度拉伸</h2><p>&emsp;&emsp;对比度拉伸是最简单的分段线性变换之一，对比度拉伸是扩展图像灰度级动态范围的处理，因此可以跨越记录介质和显示装置的全部灰度范围。下图是一个对比度拉伸的典型函数图像。<br><img src="/images/image_processing/gray_transformation/contrast_stretch.png" alt="" title="对比度拉伸"></p>
<p>&emsp;&emsp;通过变换后，灰度值在$[r_1, r_2]$范围内的像素会线性拉伸到$[s_1, s_2]$范围内，最终的结果是在范围$[r_1, r_2]$内会增强对比度，其他范围内的对比度会降低。</p>
<h2 id="灰度级分层"><a href="#灰度级分层" class="headerlink" title="灰度级分层"></a>灰度级分层</h2><p>&emsp;&emsp;用于突出图像中特定范围的亮度，可以用来增强某些特征。给个书上的例图吧，不想码字了！<br><img src="/images/image_processing/gray_transformation/grayscale_stratification.png" alt="" title="灰度级分层"></p>
<h2 id="比特平面分层"><a href="#比特平面分层" class="headerlink" title="比特平面分层"></a>比特平面分层</h2><p>&emsp;&emsp;对于8比特的灰度图，每个像素由8个比特位构成，如果把图像上所有像素的特定位置的比特位单独拿出来，就可以构成一张只包含0和1的二值图像，该图像就叫原图像的比特平面。比如取每个像素中8个比特位的第7个比特位，构成该图像的第7比特平面。<br>&emsp;&emsp;一幅图像中高位的比特平面包含了视觉上很重要的大多数数据，低位的比特平面则展现了图像更精细的灰度细节。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像内插</title>
    <url>/image_processing/interpolation/</url>
    <content><![CDATA[<p>关于常见的图像内插方法的介绍</p>
<a id="more"></a>

<p>&emsp;&emsp;内插是在诸如放大、收缩、旋转和几何校正等任务中广泛应用的基本工具，是一种基本的图像重取样方法，本质上，内插是用已知数据来估计未知位置的数值的处理。本文介绍的内插主要用于调整图像的大小（收缩和放大）。</p>
<h1 id="最近邻内插"><a href="#最近邻内插" class="headerlink" title="最近邻内插"></a>最近邻内插</h1><p>&emsp;&emsp;最近邻内插根据原图像和目标图像的尺寸，计算缩放的比例，然后根据缩放比例计算离目标像素最近的原像素，将该原像素作为目标像素。<br>&emsp;&emsp;假设原图像大小为$W_s \times H_s$，目标图像大小为$W_d \times H_d$，原图像在$(x0,y0)$位置处的像素表示为$f_s(x0,y0)$，则目标图像在$(x, y)$位置处的像素$f_d(x,y)$的计算公式如下：</p>
<p>$$f_d(x, y) = f_s(\lfloor \frac{W_s}{W_d} \times x + 0.5 \rfloor, \lfloor \frac{H_s}{H_d} \times y + 0.5 \rfloor)$$</p>
<p>&emsp;&emsp;上式中$\lfloor \frac{W_s}{W_d} \times x + 0.5 \rfloor$表示对$\frac{W_s}{W_d} \times x$四舍五入。<br>&emsp;&emsp;最近邻内插算法实现的图像缩放的原理很简单，但缺点是得到的图像效果不太好<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。代码可以参考下文的 nearest_interpolation() 函数。</p>
<h1 id="双线性内插"><a href="#双线性内插" class="headerlink" title="双线性内插"></a>双线性内插</h1><p>&emsp;&emsp;双线型内插利用了源图中虚拟点四周的四个真实存在的像素，来共同决定目标图中的一个像素，使用双线性内插的缩放效果比简单的最邻近内插要好很多。<br>计算方法：<br>&emsp;&emsp;假设原图像大小为$W_s \times H_s$，目标图像大小为$W_d \times H_d$，首先根据源图像和目标图像的尺寸比例，计算目标图像像素坐标$(x_d,y_d)$在原图像中浮点坐标$(x_f,y_f)$，计算公式如下：</p>
<p>$$x_f = \frac{W_s}{W_d} \times x_d$$</p>
<p>$$y_f = \frac{H_s}{H_d} \times y_d$$</p>
<p>&emsp;&emsp;接下来在原图像中寻找离浮点坐标$(x_f,y_f)$最近的四个像素点，分别是坐标为$(\lfloor x_f \rfloor,\lfloor y_f \rfloor)$，$(\lfloor x_f + 1 \rfloor,\lfloor y_f \rfloor)$，$(\lfloor x_f \rfloor,\lfloor y_f + 1 \rfloor)$，$(\lfloor x_f + 1 \rfloor,\lfloor y_f + 1 \rfloor)$的四个像素。根据这四个像素计算出浮点坐标的像素值，再将浮点坐标的像素值作为目标图像对应位置的像素值。浮点坐标的像素值的计算方法如下：<br>&emsp;&emsp;首先，在$x$方向上进行两次线性插值计算，计算出$(x_f,\lfloor y_f \rfloor)$和$(x_f,\lfloor y_f + 1 \rfloor)$处的像素值，计算公式如下，设原图中在点$(x,y)$处的像素值为$f_s(x,y)$</p>
<p>$$f_s(x_f,\lfloor y_f \rfloor) = (\lfloor x_f + 1 \rfloor - x_f) \times f_s(\lfloor x_f \rfloor,\lfloor y_f \rfloor) + (x_f - \lfloor x_f \rfloor) \times f_s(\lfloor x_f + 1 \rfloor,\lfloor y_f \rfloor$$</p>
<p>$$f_s(x_f,\lfloor y_f + 1 \rfloor) = (\lfloor x_f + 1 \rfloor - x_f) \times f_s(\lfloor x_f \rfloor,\lfloor y_f + 1 \rfloor) + (x_f - \lfloor x_f \rfloor) \times f_s(\lfloor x_f + 1 \rfloor,\lfloor y_f + 1 \rfloor)$$</p>
<p>&emsp;&emsp;然后利用$f_s(x_f,\lfloor y_f \rfloor)$和$f_s(x_f,\lfloor y_f + 1 \rfloor)$在$y$方向上进行一次插值计算，得出$f_s(x_f,y_f)$，计算公式如下：</p>
<p>$$f_s(x_f,y_f) = (\lfloor y_f + 1\rfloor - y_f) \times f_s(x_f,\lfloor y_f \rfloor) + (y_f - \lfloor y_f \rfloor) \times f_s(x_f,\lfloor y_f + 1 \rfloor)$$</p>
<p>&emsp;&emsp;实际上，双线性内插是根据四个像素点与浮点坐标的距离来计算四个像素点的权重，然后将四个像素点的加权平均和作为浮点坐标的像素值。图片使用双线性内插的缩放效果要优于最邻近内插，但是计算量要比最邻近内插大一点<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。代码可以参考下文的 bilinear_interpolation() 函数。</p>
<h1 id="双三次内插"><a href="#双三次内插" class="headerlink" title="双三次内插"></a>双三次内插</h1><p>&emsp;&emsp;双三次内插的原理于双线性内插相似，都是根据浮点坐标附近的像素来计算出浮点坐标的像素值，计算时也是根据与浮点坐标之间的距离来计算附近像素点的权重，最后根据附近像素点的权重和像素值取加权平均和。与双线性内插不同的是，双三次内插计算了浮点坐标附近的16个像素点，而双线性内插只计算了4个。<br>&emsp;&emsp;双三次内插的核心问题是，如何根据像素点与浮点坐标的距离计算权重，有关双三次内插的计算方法参考自<a href="https://blog.csdn.net/qq_29058565/article/details/52769497" target="_blank" rel="noopener">https://blog.csdn.net/qq_29058565/article/details/52769497</a>，我偷个懒，就不再详细解释了。<br>&emsp;&emsp;与前面两种内插方法相比，双三次内插在保存细节方面比双线性内插相对要好一些，但是计算量比前两种方法都要高一些，是商业图像编辑程序如Adobe Photoshap和Corel Photopaint的标准内插方法<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>&emsp;&emsp;使用opencv库实现的，只能处理灰度图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最近邻内插 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nearest_interpolation</span><span class="params">(Mat src, Mat &amp;dst, Size dst_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, x, y;</span><br><span class="line">	<span class="comment">/* 计算原图像与目标图像的宽度和高度比例 */</span></span><br><span class="line">	<span class="keyword">double</span> wsd = (<span class="keyword">double</span>)src.cols / dst_size.width;</span><br><span class="line">	<span class="keyword">double</span> hsd = (<span class="keyword">double</span>)src.rows / dst_size.height;</span><br><span class="line"></span><br><span class="line">	dst = Mat(dst_size, src.type());</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dst.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		y = hsd * i + <span class="number">0.5</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; dst.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			x = wsd * j + <span class="number">0.5</span>;</span><br><span class="line">			dst.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(y, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 双线性内插 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilinear_interpolation</span><span class="params">(Mat src, Mat &amp;dst, Size dst_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="comment">/* 计算原图像与目标图像的宽度和高度比例 */</span></span><br><span class="line">	<span class="keyword">double</span> wsd = (<span class="keyword">double</span>)src.cols / dst_size.width;</span><br><span class="line">	<span class="keyword">double</span> hsd = (<span class="keyword">double</span>)src.rows / dst_size.height;</span><br><span class="line">	<span class="comment">/* 表示原图中的浮点像素 */</span></span><br><span class="line">	Point2f sfp;</span><br><span class="line">	<span class="comment">/* 表示在原图中与浮点像素最近的四个整数坐标值(左x、右x、上y、下y) */</span></span><br><span class="line">	<span class="keyword">double</span> lx, rx, uy, dy;</span><br><span class="line">	<span class="comment">/* x方向的两个像素点值，xy两个方向上的像素点值 */</span></span><br><span class="line">	<span class="keyword">double</span> xf1, xf2, xyf;</span><br><span class="line"></span><br><span class="line">	dst = Mat(dst_size, src.type());</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dst.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sfp.y = hsd * i;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; dst.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sfp.x = wsd * j;</span><br><span class="line">			lx = (<span class="keyword">int</span>)sfp.x;</span><br><span class="line">			rx = lx + <span class="number">1</span>;</span><br><span class="line">			uy = (<span class="keyword">int</span>)sfp.y;</span><br><span class="line">			dy = uy + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			xf1 = (rx - sfp.x) * src.at&lt;uchar&gt;(uy, lx) + (sfp.x - lx) * src.at&lt;uchar&gt;(uy, rx);</span><br><span class="line">			xf2 = (rx - sfp.x) * src.at&lt;uchar&gt;(dy, lx) + (sfp.x - lx) * src.at&lt;uchar&gt;(dy, rx);</span><br><span class="line">			xyf = (dy - sfp.y) * xf1 + (sfp.y - uy) * xf2;</span><br><span class="line">			dst.at&lt;uchar&gt;(i, j) = (uchar)xyf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat src, dst;</span><br><span class="line">	Size dst_size = cv::Size(<span class="number">2000</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	src = cv::imread(<span class="string">"img/img1.png"</span>, cv::IMREAD_COLOR);</span><br><span class="line">	cvtColor(src, src, COLOR_BGR2GRAY);</span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	nearest_interpolation(src, dst, dst_size);</span><br><span class="line">	imshow(<span class="string">"nearest interpolation"</span>, dst);</span><br><span class="line"></span><br><span class="line">	bilinear_interpolation(src, dst, dst_size);</span><br><span class="line">	imshow(<span class="string">"bilinear interpolation"</span>, dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* opencv的双线性内插接口 */</span></span><br><span class="line">	cv::resize(src, dst, dst_size, <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);</span><br><span class="line">	imshow(<span class="string">"opencv resize"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">有关最近邻内插的内容参考了<a href="https://www.cnblogs.com/skyfsm/p/7578302.html" target="_blank" rel="noopener">https://www.cnblogs.com/skyfsm/p/7578302.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">有关双线性内插的内容参考了<a href="https://www.cnblogs.com/yssongest/p/5303151.html" target="_blank" rel="noopener">https://www.cnblogs.com/yssongest/p/5303151.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">此处引用自冈萨雷斯的《数字图像处理》第三版第37页。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的几何空间变换</title>
    <url>/image_processing/space_transformation/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;图像的几何空间变换可以改进图像中像素间的空间关系，主要由两个基本操作组成：</p>
<ul>
<li>坐标空间的变换。</li>
<li>图像内插，对空间变换后的像素赋值。</li>
</ul>
<h2 id="空间坐标变换"><a href="#空间坐标变换" class="headerlink" title="空间坐标变换"></a>空间坐标变换</h2><p>&emsp;&emsp;可由下式表示：<br>$$(x, y) = T{(v, w)}$$</p>
<p>&emsp;&emsp;上式中$(v, w)$是原图中像素的坐标，$(x, y)$是变换后图像的坐标，$T$是变换函数，也就是原图中某个位置的像素通过变换函数，映射到目标图像中。比如：$(x, y) = T{(v, w)} = (v/2, w/2)$表示在两个方向上将原图缩小一半。</p>
<h2 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h2><p>&emsp;&emsp;请参考我的另一篇博文<a href="/image_processing/interpolation/">图像内插</a>。</p>
<h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><p>&emsp;&emsp;仿射变换是最常用的空间坐标变换之一，其一般形式如下：<br>$$<br>\left[\begin{matrix} x &amp; y &amp; 1 \end{matrix}\right] =<br>\left[\begin{matrix} v &amp; w &amp; 1 \end{matrix}\right]T =<br>\left[\begin{matrix} v &amp; w &amp; 1 \end{matrix}\right]<br>\left[\begin{matrix}<br>t_{11} &amp; t_{12} &amp; 0 \\<br>t_{21} &amp; t_{22} &amp; 0 \\<br>t_{31} &amp; t_{32} &amp; 1<br>\end{matrix}\right]<br>$$</p>
<p>&emsp;&emsp;上式中，$T$表示变换矩阵，可根据$T$中元素所选择的值，对一组坐标点做尺度、旋转、平移或偏移。</p>
<table>
<thead>
<tr>
<th align="center">变换名称</th>
<th align="center">变换矩阵$T$</th>
<th align="center">坐标公式</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">恒等变换</td>
<td align="center">$\left[\begin{matrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = v \\ y = w$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_1.png" alt=""></td>
</tr>
<tr>
<td align="center">尺度变换</td>
<td align="center">$\left[\begin{matrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = c_x v \\ y = c_y w$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_2.png" alt=""></td>
</tr>
<tr>
<td align="center">平移变换</td>
<td align="center">$\left[\begin{matrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = v + t_x \\ y = w + t_y$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_3.png" alt=""></td>
</tr>
<tr>
<td align="center">旋转变换</td>
<td align="center">$\left[\begin{matrix} \cos\theta &amp; \sin\theta &amp; 0 \\ -\sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = v\cos\theta - w\sin\theta \\ y = v\sin\theta + w\cos\theta$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_4.png" alt=""></td>
</tr>
<tr>
<td align="center">垂直偏移变换</td>
<td align="center">$\left[\begin{matrix} 1 &amp; s_h &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = v \\ y = w + s_hv$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_5.png" alt=""></td>
</tr>
<tr>
<td align="center">水平偏移变换</td>
<td align="center">$\left[\begin{matrix} 1 &amp; 0 &amp; 0 \\ s_v &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{matrix}\right]$</td>
<td align="center">$x = v + s_vw \\ y = w$</td>
<td align="center"><img src="/images/image_processing/space_transformation/affine_t_6.png" alt=""></td>
</tr>
</tbody></table>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>&emsp;&emsp;实现空间变换的方法有两种：</p>
<ul>
<li><strong>前向映射</strong>：整体思想是扫描原图像，对于原图像上的每个像素，根据它在原图中的坐标$(v, w)$，利用$(x, y) = T{(v, w)}$计算其在目标图像上的坐标$(x, y)$，然后将原图中坐标为$(v, w)$的像素值赋值给目标图像中坐标为$(x, y)$的像素。</li>
<li><strong>反向映射</strong>：整体思想是扫描目标图像的每个像素，对于坐标为$(x, y)$的像素，利用$(v, w) = T^{-1}{(x, y)}$计算其在原图像上的坐标$(v, w)$，然后用内插的方法计算该像素的值。<br>&emsp;&emsp;这里$T^{-1}$表示变换函数的反函数，对于仿射变换来说，相当于$\left[\begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]$乘变换矩阵的逆矩阵。</li>
</ul>
<p>&emsp;&emsp;使用前向映射可能会存在两个问题，一个是原图像中多个像素被变换到目标图像的同一个位置，产生冲突，另一个问题是计算出的目标像素坐标不存在，比如不是个整数坐标。而反向映射不存在这两个问题，因此反向映射用的多一点。<br>&emsp;&emsp;这里给出用反向映射实现仿射变换的C++代码，代码用的是opencv库处理图像。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原图路径 */</span></span><br><span class="line"><span class="keyword">char</span> img_path[<span class="number">100</span>] = <span class="string">"img/affine.png"</span>;</span><br><span class="line"><span class="comment">/* 变换后图像的大小 */</span></span><br><span class="line">Size img_out_size = &#123;<span class="number">300</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="comment">/* 仿射矩阵 */</span></span><br><span class="line"><span class="keyword">double</span> T[<span class="number">3</span>][<span class="number">3</span>] = </span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 利用双线性内插计算原图中的浮点像素值 */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bilinear_interpolation</span><span class="params">(Mat src, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt; src.cols || y &lt; <span class="number">0</span> || y &gt; src.rows)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 表示在原图中与浮点像素最近的四个整数坐标值(lx:左x、rx:右x、uy:上y、dy:下y) */</span></span><br><span class="line">	<span class="keyword">double</span> lx = (<span class="keyword">int</span>)x;</span><br><span class="line">	<span class="keyword">double</span> rx = lx + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> uy = (<span class="keyword">int</span>)y;</span><br><span class="line">	<span class="keyword">double</span> dy = uy + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先计算y方向的两个像素点值f1、f2，再计算xy两个方向上的像素点值 */</span></span><br><span class="line">	<span class="keyword">double</span> f1 = (rx - x) * src.at&lt;uchar&gt;(uy, lx) + (x - lx) * src.at&lt;uchar&gt;(uy, rx);</span><br><span class="line">	<span class="keyword">double</span> f2 = (rx - x) * src.at&lt;uchar&gt;(dy, lx) + (x - lx) * src.at&lt;uchar&gt;(dy, rx);</span><br><span class="line">	<span class="keyword">double</span> xy = (dy - y) * f1 + (y - uy) * f2;</span><br><span class="line">	<span class="keyword">return</span> xy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	Mat src = imread(img_path, cv::IMREAD_GRAYSCALE);</span><br><span class="line">	src.rows -= <span class="number">2</span>;</span><br><span class="line">	Mat dst = Mat(img_out_size, src.type());</span><br><span class="line"></span><br><span class="line">	Mat t_s = Mat(<span class="number">3</span>, <span class="number">3</span>, CV_64FC1, T);</span><br><span class="line">	Mat t_inv = Mat(<span class="number">3</span>, <span class="number">3</span>, CV_64FC1);</span><br><span class="line">	invert(t_s, t_inv); <span class="comment">// t_inv为仿射矩阵的逆矩阵</span></span><br><span class="line"></span><br><span class="line">	Mat src_vec, dst_vec;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dst.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; dst.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 目标图像的坐标向量 */</span></span><br><span class="line">			dst_vec = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; j, i, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* 计算dst_vec对应于原图中的坐标向量src_vec */</span></span><br><span class="line">			src_vec = dst_vec * t_inv;</span><br><span class="line">			<span class="comment">/* 计算目标图像的浮点像素值 */</span></span><br><span class="line">			dst.at&lt;uchar&gt;(i, j) = (uchar)bilinear_interpolation(src, src_vec.at&lt;<span class="keyword">double_t</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), src_vec.at&lt;<span class="keyword">double_t</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line">	imwrite(<span class="string">"img/t_1.png"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法教程</title>
    <url>/learn_note/markdown_base/</url>
    <content><![CDATA[<p>从网上收集的markdown语法教程</p>
<a id="more"></a>


<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>&emsp;&emsp;前两天用Gridea和Github Pages搭好了我的博客，不得不说，这两个都是好东西，而且都是免费的。Gridea用来搭建个人博客容易，而且人性化，适合像我这样的菜鸟上手，Github Pages提供平台展示博客。在这里感谢一下<a href="https://gridea.dev/" target="_blank" rel="noopener">Gridea</a>和<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>的开发者们。<br>&emsp;&emsp;Gridea支持Markdown语法，我这个菜鸟又不会，所以打算学一下，顺便写一篇介绍基本语法的博文，作为我的第一篇博文，下面进入正题吧！</p>
<h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>&emsp;&emsp;Markdown 语言由约翰·格鲁伯(John Gruber)于2004年创建，是一种轻量级标记语言。Markdown允许人们使用易读易写的纯文本来编写带样式的文档，有点类似html，不过它比html简单一些。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。使用Markdown 编写的文档后缀为 .md, .markdown，比如github仓库里的README.md文档。</p>
<p>&emsp;&emsp;关于Markdown的编辑器，可分为以下三类：</p>
<ol>
<li>平台集成工具：各大在线博客、社区平台自带的写作工具，比如CSDN、博客园、简书等。</li>
<li>独立软件类：在本地上使用的独立软件，可以编辑本地文件，比如Typora、Haroopad等。</li>
<li>插件类：有些编辑器安装相应的插件，可以具有Markdown的功能，比如Atom、VS code、Sublime Text等。</li>
</ol>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>&emsp;&emsp;标题可以使用两种方式来设置，一种是用“=”和“-”，一种是用“#”。</p>
<ol>
<li>使用“=”和“-”符号，在标题的下一行加一个“=”，就会有一级标题的效果，如果加“-”的话就是二级标题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 一级标题</span><br><span class="line">&#x3D;</span><br><span class="line">二级标题</span><br><span class="line">-</span><br></pre></td></tr></table></figure>
效果如下：</li>
</ol>
<p><img src="/images/learn_note/markdown_base/1581056192563.png" alt=""></p>
<p>&emsp;&emsp;需要注意的是，使用这种方式的标题，上一行如果是普通文本，两行之间要加一个换行，不然上一行文本也会有标题的样式。</p>
<ol start="2">
<li>使用“#”符号，在标题的前面加“#”符号就好了，加几个“#”就代表几级标题，最多支持6级标题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
效果如下：</li>
</ol>
<p><img src="/images/learn_note/markdown_base/1581056288407.png" alt=""></p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="简单字体"><a href="#简单字体" class="headerlink" title="简单字体"></a>简单字体</h2><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br><span class="line">&lt;u&gt;带下划线文本&lt;&#x2F;u&gt;</span><br><span class="line">~~带删除线文本~~</span><br></pre></td></tr></table></figure>
<p>效果如下：<br>&emsp;&emsp; <em>斜体文本</em><br>&emsp;&emsp; <em>斜体文本</em><br>&emsp;&emsp; <strong>粗体文本</strong><br>&emsp;&emsp; <strong>粗体文本</strong><br>&emsp;&emsp; <strong><em>粗斜体文本</em></strong><br>&emsp;&emsp; <strong><em>粗斜体文本</em></strong><br>&emsp;&emsp; <u>带下划线文本</u><br>&emsp;&emsp; <del>带删除线文本</del></p>
<h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h2><p>Markdown的最初目标就是为纯写作而生的，因此，它并没有考虑文字的更多样式。如果想使用更多字体样式，可以借助html的font标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;red&gt;红色字体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;6&gt;6号字体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;red size&#x3D;6&gt;6号红色字体&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>&emsp;&emsp; <font color=red>红色字体</font></p>
<p>&emsp;&emsp; <font size=6>6号字体</font></p>
<p>&emsp;&emsp; <font color=red size=6>6号红色字体</font></p>
<h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><p>Markdown不能直接用键盘输入的空格和回车来表示空格，需要用特殊符号。<br><code>&amp;ensp;</code>或<code>&amp;#8194;</code>表示半角空格(En Space)，占一个字符，相当于半个汉字的长度。<br><code>&amp;emsp;</code>或<code>&amp;#8195;</code>表示全角空格(Em Space)，占两个字符，相当于一个汉字的长度。<br><code>&amp;nbsp;</code>或<code>&amp;#160;</code>不换行空格(No-Break Space)，占一个字符，相当于一个字符”n”的长度。<br>半角空格和全角空格推荐在中文里使用，不换行空格推荐在英文里使用。</p>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>markdown里敲多个换行只能显示一个，如果想显示多个换行，需要用<code>&lt;br&gt;</code>或者<code>&lt;br/&gt;</code>来表示。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用的文字段落会高亮显示，方法是在文字开头加”&gt;”符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="简单图片"><a href="#简单图片" class="headerlink" title="简单图片"></a>简单图片</h2><p>如果是想简单的显示图片，使用以下方式就好了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](图片地址)</span><br></pre></td></tr></table></figure>
<p>图片链接地址可以是本地图片文件地址，也可以是网络图片地址。</p>
<p>也可以给图片添加说明和标题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片说明文字](图片链接地址 &quot;图片标题&quot;)</span><br></pre></td></tr></table></figure>
<p>图片说明文字会在图片无法加载时显示，图片正常加载时说明文字不显示，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这是一张无法加载的图片](错误的图片地址 &quot;title&quot;)</span><br></pre></td></tr></table></figure>
<p>显示为<br><img src="%E9%94%99%E8%AF%AF%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="这是一张无法加载的图片" title="title"><br>如果图片有标题，当鼠标停在图片上时会显示出来，即使图片无法加载，鼠标停靠时也会显示，下面是一个例子，请读者自行尝试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![涅普迪努](&#x2F;images&#x2F;learn_note&#x2F;markdown_base&#x2F;nepnep.png &quot;我可爱吗^_^&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/learn_note/markdown_base/nepnep.png" alt="涅普迪努" title="我可爱吗^_^"></p>
<h2 id="自定义图片"><a href="#自定义图片" class="headerlink" title="自定义图片"></a>自定义图片</h2><p>Markdown无法自定义图片的宽度和高度，如果想改变的话需要借助html的img标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img width&#x3D;100 height&#x3D;160 src&#x3D;&quot;https:&#x2F;&#x2F;stxw.ml&#x2F;images&#x2F;learn_note&#x2F;markdown_base&#x2F;nepnep.png&quot; title&#x3D;&quot;我是变小后的涅普迪努&quot;&gt;&lt;&#x2F;img&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一张100×160的图片<br><img width=100 height=160 src="/images/learn_note/markdown_base/nepnep.png" title="我是变小后的涅普迪努"></img></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p>markdown可以使用两种方法创建链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<p>以github主页为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[github](https:&#x2F;&#x2F;github.com)</span><br><span class="line">&lt;https:&#x2F;&#x2F;github.com&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><a href="https://github.com" target="_blank" rel="noopener">github</a><br><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p>
<h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><p>可以使用内部链接跳转到本文内某个标题的位置，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名字][#标题名字]</span><br></pre></td></tr></table></figure>
<p>比如想跳转转到本文的“Markdown简介”的位置，可以用下面的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Markdown简介](#Markdown简介)</span><br></pre></td></tr></table></figure>
<p><a href="#Markdown简介">Markdown简介</a></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<p>markdown会对数字重新按顺序编号，比如下面代码显示的编号任然是1.2.3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">1. 第二项</span><br><span class="line">237. 第三项</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>设置表格的对齐方式：</p>
<ul>
<li>-: 设置内容和标题栏居右对齐。</li>
<li>:- 设置内容和标题栏居左对齐。</li>
<li>:-: 设置内容和标题栏居中对齐。</li>
</ul>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐的一列 | 右对齐的一列 | 居中对齐的一列 |</span><br><span class="line">| :----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
<p> 显示效果：</p>
<table>
<thead>
<tr>
<th align="left">左对齐的一列</th>
<th align="right">右对齐的一列</th>
<th align="center">居中对齐的一列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p>代码片段可以用一个或两个反引号”`“包起来，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c语言常用&#96;scanf()&#96;和&#96;&#96;printf()&#96;&#96;函数来输入输出。</span><br></pre></td></tr></table></figure>
<p>显示为：c语言常用<code>scanf()</code>和<code>printf()</code>函数来输入输出。</p>
<h2 id="代码段落"><a href="#代码段落" class="headerlink" title="代码段落"></a>代码段落</h2><p>代码段落可以用三个反引号”```”或三个”~~~”来显示(三个以上也可以)，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, int argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<p>显示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, int argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的三个反引号后面加入编程语言的关键字，还可以显示语法高亮，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def sigmoid(self, input):</span><br><span class="line">    return 1.0 &#x2F; (1.0 + np.exp(-input))</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<p>显示为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, input)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + np.exp(-input))</span><br></pre></td></tr></table></figure>
<p>以下为常用的语言的语法关键字</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>cpp, c</td>
</tr>
<tr>
<td>Java</td>
<td>java</td>
</tr>
<tr>
<td>Python</td>
<td>py, python</td>
</tr>
<tr>
<td>Shell</td>
<td>bash, shell</td>
</tr>
<tr>
<td>C#</td>
<td>csharp, c#</td>
</tr>
<tr>
<td>CSS</td>
<td>css</td>
</tr>
<tr>
<td>JavaScript</td>
<td>js, jscript, javascript</td>
</tr>
<tr>
<td>XML</td>
<td>xml , xhtml, xslt, html</td>
</tr>
<tr>
<td>PHP</td>
<td>php</td>
</tr>
<tr>
<td>SQL</td>
<td>sql</td>
</tr>
</tbody></table>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>&emsp;&emsp;markdown里有些字符代表特殊功能，比如 * 代表无序列表开始标志，如果只是想显示这些符号，而不使用符号的特殊功能，需要在符号前加一个 \ ，markdown里需要转义的字符如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>原始字符</th>
<th>显示效果</th>
</tr>
</thead>
<tbody><tr>
<td>反斜杠</td>
<td>\\</td>
<td>\</td>
</tr>
<tr>
<td>反引号</td>
<td>\`</td>
<td>`</td>
</tr>
<tr>
<td>星号</td>
<td>\*</td>
<td>*</td>
</tr>
<tr>
<td>井号</td>
<td>\#</td>
<td>#</td>
</tr>
<tr>
<td>加号</td>
<td>\+</td>
<td>+</td>
</tr>
<tr>
<td>减号</td>
<td>\-</td>
<td>-</td>
</tr>
<tr>
<td>点</td>
<td>\.</td>
<td>.</td>
</tr>
<tr>
<td>感叹号</td>
<td>\!</td>
<td>!</td>
</tr>
<tr>
<td>大括号</td>
<td>\{\}</td>
<td>{}</td>
</tr>
<tr>
<td>中括号</td>
<td>\[\]</td>
<td>[]</td>
</tr>
<tr>
<td>小括号</td>
<td>\(\)</td>
<td>()</td>
</tr>
</tbody></table>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>&emsp;&emsp;部分markdown平台支持目录自动生成，比如gridea可以用<code>@[TOC]</code>来插入目录，Typora用<code>[TOC]</code>插入目录。如果平台不支持的话，可以使用mardown的编辑器来生成，或者使用上面提到的列表和内部链接自己做一个，当然这样比较麻烦，而且无法与标题自动同步。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>markdown支持添加脚注，点击脚注后，会跳转到文档的底部的说明位置，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^关键字]</span><br><span class="line">[^关键字]: 脚注说明内容</span><br></pre></td></tr></table></figure>
<p>第一行代码添加了一个脚注，第二行代码对脚注进行了定义，如果对添加的脚注不进行定义的话，脚注无法显示。markdown在显示脚注的时候会按照顺序进行编号，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本[^第一个脚注]</span><br><span class="line">[^第一个脚注]: 这里是第一个脚注的说明。</span><br><span class="line"></span><br><span class="line">文本[^第二脚注]</span><br><span class="line">[^第二脚注]: 这里是第二个脚注的说明。</span><br></pre></td></tr></table></figure>
<p>显示结果：<br>文本<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>文本<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>markdown可以在一行上连用三个或者三个以上的星号、减号、或者下划线来表示分割线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<hr>
<hr>
<hr>
<h2 id="数学公式和画图"><a href="#数学公式和画图" class="headerlink" title="数学公式和画图"></a>数学公式和画图</h2><p>可以参考这个大佬的链接<a href="https://www.cnblogs.com/yalphait/articles/8685586.html" target="_blank" rel="noopener">https://www.cnblogs.com/yalphait/articles/8685586.html</a><br><br/></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">这里是第一个脚注的说明。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">这里是第二个脚注的说明。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本基础知识</title>
    <url>/learn_note/shell_script_base/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>&emsp;&emsp;shell是操作系统内核之外的指令解析器，是一个程序，同时是一种命令语言和程序设计语言。是处于操作人员和操作系统接口之间的一层封装，用于方便操作人员使用计算机。<br>用途：</p>
<ol>
<li>用于计算机的启动、常用程序的运行等脚本。</li>
<li>作为配置文件。</li>
<li>处理文本文件。</li>
</ol>
<p>&emsp;&emsp;常用的shell：sh、bash。</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>&emsp;&emsp;将多行命令封装进一个文本文件里，执行一个shell脚本即可执行多个shell命令。<br>&emsp;&emsp;shell的第一行用于指定脚本解释器的路径，方法是<code>#!解释器的路径</code>，比如指定为/bin/sh的代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br></pre></td></tr></table></figure>

<h1 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h1><p>&emsp;&emsp;shell有两种执行方式，第一种是<code>脚本解释器 shell文件</code>，第二种是<code>./shell文件</code>。使用第二种方式时，要确保shell文件有可执行权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash ./test.sh  # 第一种方式</span><br><span class="line">./test.sh  # 第二种方式</span><br></pre></td></tr></table></figure>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>&emsp;&emsp;shell脚本里用#来表示单行注释，如果使用第一种方式执行shell，第一行的<code>#!</code>也是注释；如果用第二种方式执行shell，第一行的<code>#!</code>则不是注释。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是一个注释</span></span><br><span class="line">ls -l # 这也是一个注释</span><br></pre></td></tr></table></figure>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ol>
<li>方法一</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">: '</span><br><span class="line">echo "这是一个注释"</span><br><span class="line">echo "这也是注释"</span><br><span class="line">echo "这还是注释"</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：注释的开头的<code>:</code>和<code>&#39;</code>之间有一个空格，不然会报错。</p>
<ol start="2">
<li>方法二</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt; 字符</span><br><span class="line">echo "这是一个注释"</span><br><span class="line">echo "这也是注释"</span><br><span class="line">echo "这还是注释"</span><br><span class="line">字符</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的字符上下两个要相同，否则注释无法结束。</p>
<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>&emsp;&emsp;给命令取其他名字，用来简化带参数的命令，比如使用<code>alias ll=&#39;ls -l&#39;</code>命令来给<code>ls -l</code>取一个<code>ll</code>的别名，以后就可以用<code>ll</code>来代替<code>ls -l</code>了。<br>&emsp;&emsp;如果是在终端输入<code>alias</code>命令后取的别名，在终端退出后别名就会失效，下次开启终端后，需要再执行一次<code>alias</code>命令才能使用别名。如果想要在每次开启终端后都能使用别名，需要把<code>alias</code>命令写入~/.bashrc文件里。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>&emsp;&emsp;echo命令用于将字符输出到标准输出，语法：<code>echo [可选项] 要输出的字符串...</code>，可选项有两个：</p>
<ul>
<li>-n ：输出后不换行，默认会换一行。</li>
<li>-e ：输出前解析转义字符（类似<code>\n</code>之类的），默认不解析。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'abc!'</span>   <span class="comment"># 输出后会换一行</span></span></span><br><span class="line">abc!</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">'abc!'</span>   <span class="comment"># 输出后不换行</span></span></span><br><span class="line">abc!$ </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'abc\nabc'</span>  <span class="comment"># 不解析转义字符，将\n当做普通字符串输出</span></span></span><br><span class="line">abc\nabc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">'abc\nabc'</span>  <span class="comment"># 解析转义字符，将\n当做换行符输出</span></span></span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;cat命令用于将文件的内容输出到标准输出，语法：<code>cat 要输出的文件</code>。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>&emsp;&emsp;read命令会从标准输入中读取字符串，保存到变量中，语法：<code>read 保存输入的变量</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> VAR</span></span><br><span class="line">abc   # 输入的字符串</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR&#125;</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也可以用read命令将读取的字符串保存到多个变量中，语法：<code>read 变量1 变量2 ...</code>。read命令读取到空格就换一个变量来保存字符串，读取到回车停止读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> VAR1 VAR2</span></span><br><span class="line">abc 123  # 输入的字符串</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR1&#125;</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR2&#125;</span></span></span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用read将输入保存到变量时，如果想将空格当做普通字符保存到变量中，可以在空格前加一个反斜杠来转义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> VAR1 VAR2</span></span><br><span class="line">abc\ 123 xyz       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR1&#125;</span></span></span><br><span class="line">abc 123</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR2&#125;</span></span></span><br><span class="line">xyz</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当用来保存输入的变量是最后一个变量的时候，即使不加反斜杠来转义，也会把空格当做普通字符来处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> VAR1 VAR2</span></span><br><span class="line">abc 123 xyz</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR1&#125;</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR2&#125;</span></span></span><br><span class="line">123 xyz  # 变量VAR2是最后一个保存输入的变量</span><br><span class="line"><span class="meta">$</span><span class="bash">   <span class="comment"># 所以“123”和“xyz”之间的空格，即使不加反斜杠，也当做普通字符处理</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果后面的变量还没有用到，read就读取到了换行，那么，没用到的变量会赋值为空字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR1=xyz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> VAR2=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> VAR1 VAR2</span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR1&#125;</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR2&#125;</span> <span class="comment"># 变量VAR2原来是123，现在是空字符串。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>


<h2 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h2><p>&emsp;&emsp;一个进程启动时，默认会打开3个文件描述符。</p>
<ul>
<li>0 标准输入　STDIN_FILENO</li>
<li>1 标准输出　STDOUT_FILENO</li>
<li>2 标准错误　STDERR_FILENO</li>
</ul>
<p>&emsp;&emsp;一般在终端运行的命令会将当前终端作为标准输入、标准输出和标准错误，如果想用一个文件去替换终端，作为该命令的标准输入、标准输出或者标准错误，则需要用到输入输出重定向。输入输出重定向的语法如下：</p>
<ul>
<li><code>commad 0&lt;file</code> ：将file文件作为commad命令的标准输入，0可以省略。</li>
<li><code>commad 1&gt;file</code> ：将commad命令的标准输出重定向到file文件，会覆盖file文件原来的内容，用<code>&gt;&gt;</code>替换<code>&gt;</code>就不会覆盖，会将标准输出追加到file文件里。1也可以省略，效果是一样的。</li>
<li><code>commad 2&gt;file</code> ：将commad命令的标准错误重定向到file文件，覆盖写入，用<code>&gt;&gt;</code>表示追加，这里2不可以省略。</li>
<li><code>commad 1&gt;file 2&gt;&amp;1</code> ：将commad命令的标准输出和标准错误都重定向到file文件，会覆盖file文件原来的内容，用<code>&gt;&gt;</code>表示追加，前面的1可以省略。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out &lt;in.txt    # 将in.txt文件作为./a.out的输入</span><br><span class="line">./a.out &gt;out.txt   # 将./a.out的标准输出重定向到out.txt文件中，覆盖写入</span><br><span class="line">./a.out &gt;&gt;out.txt   # 将./a.out的标准输出重定向到out.txt文件中，追加写入</span><br><span class="line">./a.out 2&gt;out.txt   # 将./a.out的标准错误重定向到out.txt文件中，覆盖写入</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>&emsp;&emsp;用<code>|</code>表示，即将前一条命令的执行结果，利用管道传给下一条命令，作为下一条命令的输入，比如查看test.cpp文件里所有包含<code>printf</code>的行可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test.cpp | grep <span class="string">'printf'</span></span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>&emsp;&emsp;变量是一段内存名字。shell里只有字符串和整数两种类型的变量。shell变量常用大写英文字符表示。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>&emsp;&emsp;shell变量可以用<code>declare</code>来声明。设定属性的选项：</p>
<ul>
<li>-a&emsp;声明下标数组 (如果支持)</li>
<li>-A&emsp;声明关联数组 (如果支持)</li>
<li>-i&emsp;声明整型变量</li>
<li>-r&emsp;声明只读变量</li>
<li>-n&emsp;声明指向一个以其值为名称的变量的引用</li>
<li>-x&emsp;声明一个变量，并将变量导出，有关导出的内容会在下文的<a href="#环境变量">环境变量</a>里解释。</li>
<li>-t&emsp;声明带有`trace’(追踪)属性的变量</li>
<li>-l&emsp;将变量在赋值时转为小写</li>
<li>-u&emsp;将变量在赋值时转为大写</li>
</ul>
<p>&emsp;&emsp;如果在声明变量时，不指定任何属性，则默认为声明一个字符串类型的变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">声明一个下标数组</span></span><br><span class="line">declare -a MY_ARRAY</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">声明一个整型变量</span></span><br><span class="line">declare -i MY_INT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">声明一个只读变量，并将其初始化为<span class="string">'123'</span></span></span><br><span class="line">declare -r MY_READ_ONLY='123'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">声明一个变量，并将变量导出</span></span><br><span class="line">declare -x MY_EXPORT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">声明一个字符串变量</span></span><br><span class="line">declare MY_STRING</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其实，字符串类型的变量不用<code>declare</code>声明也可以赋值或者使用，相当于一个空字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"MY_VAR=<span class="variable">$&#123;MY_VAR&#125;</span>;"</span> <span class="comment">#在没有用`declare`声明时，使用'MY_VAR'变量</span></span></span><br><span class="line">MY_VAR=;</span><br><span class="line"><span class="meta">$</span><span class="bash"> MY_VAR=123 <span class="comment">#在没有用`declare`声明时，给'MY_VAR'变量赋值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"MY_VAR=<span class="variable">$&#123;MY_VAR&#125;</span>;"</span></span></span><br><span class="line">MY_VAR=123;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>语法：<code>$变量名</code>或<code>${变量名}</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $VAR</span><br><span class="line">echo $&#123;VAR&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;推荐使用加大括号的方式，可以增强代码的可读性。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>语法：<code>变量名=给变量赋的值</code><br>&emsp;&emsp;赋值和初始化时等号两边不要加空格。<br>&emsp;&emsp;只读变量初始化后不能再赋值了。</p>
<h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p>语法：<code>unset 变量名</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"VAR=<span class="variable">$&#123;VAR&#125;</span>;"</span></span></span><br><span class="line">VAR=123;</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> VAR</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"VAR=<span class="variable">$&#123;VAR&#125;</span>;"</span></span></span><br><span class="line">VAR=;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;变量VAR在释放之前的值是123，在释放之后是一个空字符串。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>&emsp;&emsp;局部变量(local variable)是用户自定义的变量，<code>declace</code>不加<code>-x</code>声明的变量都是局部变量。局部变量只在当前shell进程中有效，其父shell进程和其创建的子shell进程都无法使用。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>&emsp;&emsp;环境变量(global variable)也叫全局变量。与局部变量不同，当前shell进程在创建子shell进程时，会将环境变量复制给子shell进程，使其成为子进程的环境变量，而当前shell进程的局部变量不会复制。<br>&emsp;&emsp;可以用<code>export</code>将局部变量导出为环境变量，语法：<code>export 要导出的局部变量名</code>。<br>&emsp;&emsp;下面，用两个例子来说明环境变量和局部变量的区别。假设当前目录下有一个test.sh脚本，里面只有一条<code>echo</code>命令，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "VAR=$&#123;VAR&#125;;"</span><br></pre></td></tr></table></figure>
<p><strong>第一个例子</strong><br>&emsp;&emsp;首先在终端中声明一个名称为VAR的局部变量，然后用bash执行test.sh脚本，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> VAR=<span class="string">'123'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash ./test.sh</span></span><br><span class="line">VAR=;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个例子中，当前终端可以当做一个shell进程，执行<code>bash ./test.sh</code>命令会创建一个子shell进程，然后用创建的子shell进程去解析test.sh里的命令。因为VAR是一个局部变量，所以在创建子shell进程时，不会将VAR变量复制给子shell进程，所以子shell进程执行test.sh后输出的VAR是一个空字符串。</p>
<p><strong>第二个例子</strong><br>&emsp;&emsp;首先在终端中声明一个名称为VAR的局部变量，先将VAR用<code>export</code>导出为环境变量，然后再用bash执行test.sh脚本，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> VAR=<span class="string">'123'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> VAR</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash ./test.sh </span></span><br><span class="line">VAR=123;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与第一个例子不同的地方是VAR被导出成了环境变量，当前终端在创建子shell进程的时候会将VAR复制，成为子shell进程的环境变量，所以输出的VAR是字符串’123’。</p>
<hr>
<p>&emsp;&emsp;可以用<code>env</code>、<code>export</code>、<code>set</code>命令来查看当前shell进程的环境变量。<br>&emsp;&emsp;常用的环境变量：</p>
<ul>
<li><strong>HOME</strong>：home目录路径</li>
<li><strong>PWD</strong>：当前目录路径</li>
<li><strong>LOGNAME</strong>：当前用户用户名</li>
<li><strong>PATH</strong>：shell命令的存放路径，每个路径用引号分隔，用于shell寻找命令。</li>
</ul>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul>
<li><strong>$0</strong>：用于保存的是当前运行的可执行文件的名字。</li>
<li><strong>$1~9</strong>：用于保存给shell脚本或者shell脚本里的函数传的参数，一共有9个。</li>
<li><strong>$#</strong>：用于保存传的参数个数，$0不在计数范围内。</li>
<li><strong>$*</strong>：以单个字符串的形式保存传的参数，即$1~9，不包括$0。</li>
<li><strong>$@</strong>：以字符串数组的形式保存传的参数，不包括$0。</li>
<li><strong>$?</strong>：用于保存上一条命令或者函数的返回值，值为0表示正常退出。</li>
<li><strong>$$</strong>：当前shell进程的PID。</li>
<li><strong>$!</strong>：用于保存上一个放到后台运行的进程的PID，注意，不是前台进程。</li>
<li><strong>$-</strong>：显示shell使用的当前选项，与set命令功能相同。(这个没弄懂)</li>
</ul>
<h1 id="后台切换"><a href="#后台切换" class="headerlink" title="后台切换"></a>后台切换</h1><p>&emsp;&emsp;在命令后面加一个<code>&amp;</code>可以将该命令切换到后台工作，这样不用等待该命令结束就可以执行下一条命令了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;a.out &amp;</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面这个例子，假设<code>./a.out</code>需要执行10秒，如果不加<code>&amp;</code>，则<code>ls -l</code>需要等10秒后，也就是<code>./a.out</code>执行结束后才能运行，加了<code>&amp;</code>就不需要等待<code>./a.out</code>结束就能运行<code>ls -l</code>了。<br>&emsp;&emsp;使用这种切换到后台的进程，在终端退出后就会结束，如果想在退出终端后，后台进程任然继续运行，需要用到<code>nohup</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;a.out &amp;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用<code>nohup</code>命令会将切换到后台的进程的输出写入到当前目录的nohup.out文件里。</p>
<h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>&emsp;&emsp;双引号用来使shell将空格、制表符和其他大多数特殊字符当做普通字符来处理。举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch aaa bbb</span><br><span class="line">touch "aaa bbb"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;没加双引号时，<code>aaa</code>和<code>bbb</code>之间的空格表示命令参数分隔符，<code>touch</code>命令会创建两个文件“aaa”和“bbb”。<br>&emsp;&emsp;加了双引号时，<code>aaa</code>和<code>bbb</code>之间的空格表示普通字符，与a和b的意义相同，<code>touch</code>命令只会创建一个文件“aaa bbb”。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>&emsp;&emsp;作用与双引号类似，区别是双引号只能将空格、制表符等部分特殊符号当普通字符来处理，而单引号可以作用于所有字符。比如<code>$</code>符号(用于引用变量)加了双引号还是特殊字符，加单引号则表示普通字符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;PATH&#125;</span><br><span class="line">echo "$&#123;PATH&#125;"</span><br><span class="line">echo '$&#123;PATH&#125;'</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的三行命令，第一行和第二行的作用相同，都是输出PATH变量，第三行命令只会输出字符串“$PATH”。</p>
<h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>&emsp;&emsp;反引号用于使shell将字符串当做命令来处理。举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo ls -l</span><br><span class="line">echo `ls -l`</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一行命令会将字符串“ls -l”输出，第二行命令则会先执行<code>ls -l</code>命令，然后用<code>echo</code>命令将<code>ls -l</code>的执行结果输出。<br>&emsp;&emsp;反引号也可以用<code>$()</code>来代替，比如<code>`ls -l`</code>和<code>$(ls -l)</code>是等效的。</p>
<h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>&emsp;&emsp;转义字符，将反斜杠后面的字符当做普通字符来处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch aaa\ bbb</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面命令里的空格被转义为普通字符，执行命令后会创建一个“aaa bbb”文件。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>&emsp;&emsp;可以在一行执行多条命令，分号表示一条命令的结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "hello world"; ls -la;</span><br></pre></td></tr></table></figure>

<h2 id="空格、制表符、换行符"><a href="#空格、制表符、换行符" class="headerlink" title="空格、制表符、换行符"></a>空格、制表符、换行符</h2><p>&emsp;&emsp;当做空白。</p>
<h2 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h2><ol>
<li><strong>*?!^</strong>：用于shell的<a href="#模式">模式</a>匹配。</li>
<li><strong>&lt;&gt;</strong>：用于输入输出重定向，见<a href="#文件重定向">文件重定向</a>。</li>
<li><strong>|</strong>：用于使用管道，见<a href="#管道">管道</a>。</li>
<li><strong>$</strong>：用于引用变量，见<a href="#变量">变量</a>。</li>
<li><strong>&amp;</strong>：将命令放到后台运行，见<a href="#后台切换">后台切换</a>。</li>
<li><strong>#</strong>：在shell脚本里表示单行注释，见<a href="#单行注释">单行注释</a>。</li>
<li><strong>()</strong>：<code>$()</code>用来表示括号里的是命令，和<a href="#反引号">反引号</a>作用相同。<code>$(())</code>用来表示<a href="#表达式运算">表达式运算</a>。</li>
<li><strong>[]</strong>：用于shell的<a href="#模式">模式</a>匹配，或者用来表示<a href="#表达式运算">表达式运算</a>，也可以用来表示<a href="#条件判断">条件判断</a>。</li>
<li><strong>{}</strong>：用于shell的<a href="#模式">模式</a>匹配，或者用来引用<a href="#变量">变量</a>，也可以用来生成序列，用法见<a href="#for语句">for语句</a>。</li>
</ol>
<h1 id="模式和正则表达式"><a href="#模式和正则表达式" class="headerlink" title="模式和正则表达式"></a>模式和正则表达式</h1><p>&emsp;&emsp;shell里的模式一般用来匹配文件路径，正则表达式则是用来匹配字符串的。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>&emsp;&emsp;shell的模式包括普通字符和通配符，这里列出常用的一些通配符：</p>
<table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">含义</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*</code></td>
<td align="center">匹配0个或多个字符</td>
<td align="left"><code>a*b</code>，a与b之间可以有任意长度的任意字符, 也可以一个也没有，比如：aabcb, axyzb, a012b, ab。</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="center">匹配任意一个字符</td>
<td align="left"><code>a?b</code>，a与b之间必须也只能有一个字符, 可以是任意字符，比如：aab, abb, acb, a0b。</td>
</tr>
<tr>
<td align="center"><code>[list]</code></td>
<td align="center">匹配list中的任意单一字符</td>
<td align="left"><code>a[xyz]b</code>，a与b之间必须也只能有一个字符, 但只能是x或y或z, 比如：axb, ayb, azb。</td>
</tr>
<tr>
<td align="center"><code>[c1-c2]</code></td>
<td align="center">匹配c1到c2之间的任意一个字符</td>
<td align="left"><code>a[0-9]b</code>，a与b之间必须也只能有一个0到9之间的字符，比如：a0b, a1b… a9b。</td>
</tr>
<tr>
<td align="center"><code>[!list]</code>或<code>[^list]</code></td>
<td align="center">匹配除list中的任意单一字符</td>
<td align="left"><code>a[!xyz]b</code>，a与b之间必须也只能有一个字符, 但不能是x、y、z, 比如：a0b, apb, a-b。</td>
</tr>
<tr>
<td align="center"><code>[!c1-c2]</code>或<code>[^c1-c2]</code></td>
<td align="center">匹配不在c1-c2的任意字符</td>
<td align="left"><code>a[!0-9]b</code>，比如：acb adb。</td>
</tr>
<tr>
<td align="center"><code>{string1,string2,...}</code></td>
<td align="center">匹配sring1或string2(或更多)其一字符串</td>
<td align="left"><code>a{abc,xyz,123}b</code>，a与b之间必须是abc或xyz或123，比如：aabcb,axyzb,a123b</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;shell里的模式一般用来匹配多个文件或文件夹的路径，使用模式的常用命令有：ls、find、cp、mv、chmod…。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -1 test_[0-9].sh</span></span><br><span class="line">test_0.sh</span><br><span class="line">test_1.sh</span><br><span class="line">test_2.sh</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>&emsp;&emsp;正则表达式是用来匹配字符串的。linux里的grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来，这里用grep来演示正则表达式。<br>&emsp;&emsp;正则表达式常用元字符集：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\</code></td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="left">匹配字符串的开始位置</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td align="left">匹配字符串的结束位置</td>
</tr>
<tr>
<td align="center"><code>.</code></td>
<td align="left">匹配任意一个字符</td>
</tr>
<tr>
<td align="center"><code>[list]</code></td>
<td align="left">匹配list里的任意一个字符。例如，<code>[abc]</code>可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td align="center"><code>[^list]</code></td>
<td align="left">匹配除了list里的其他任意一个字符。例如，<code>[^abc]</code>可以匹配”plain”中的’p’、’l’、’i’、’n’。</td>
</tr>
<tr>
<td align="center"><code>[c1-c2]</code></td>
<td align="left">匹配c1到c2之间的任意字符。例如，<code>[a-z]</code>可以匹配’a’到’z’范围内的任意小写字母字符。</td>
</tr>
<tr>
<td align="center"><code>[^c1-c2]</code></td>
<td align="left">匹配不在c1到c2之间的任意字符。例如，<code>[^a-z]</code>可以匹配任何不在’a’ 到’z’范围内的任意字符。</td>
</tr>
<tr>
<td align="center"><code>x|y</code></td>
<td align="left">匹配x或y。例如，<code>z|food</code>能匹配”z”或”food”，<code>(z|f)ood</code>则匹配”zood”或”food”。</td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="left">标记一个子表达式的开始和结束位置。</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="left">匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配”z”以及”zoo”。<code>*</code>等价于<code>{0,}</code>。</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="left">匹配前面的子表达式一次或多次。例如，<code>zo+</code>能匹配”zo”以及”zoo”，但不能匹配 “z”。<code>+</code>等价于<code>{1,}</code>。</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="left">匹配前面的子表达式零次或一次。例如，<code>do(es)?</code>可以匹配”do”或”does”。<code>?</code>等价于<code>{0,1}</code>。</td>
</tr>
<tr>
<td align="center"><code>{n}</code></td>
<td align="left">匹配前面的子表达式确定的n次。例如，<code>o{2}</code>不能匹配”Bob”中的’o’，但是能匹配”food”中的两个’o’。</td>
</tr>
<tr>
<td align="center"><code>{n,}</code></td>
<td align="left">至少匹配前面的子表达式n次。例如，<code>o{2,}</code>不能匹配 “Bob” 中的 ‘o’，但能匹配”foooood”中的所有’o’。</td>
</tr>
<tr>
<td align="center"><code>{n,m}</code></td>
<td align="left">最少匹配前面的子表达式n次且最多匹配m次。例如，<code>o{1,3}</code>将匹配”fooooood”中的前三个’o’。注意，在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td align="center"><code>\b</code></td>
<td align="left">匹配一个单词边界，也就是指单词和空格(shell里的grep并不限于空格，单词和’.’、’_’之间也能匹配)间的位置。例如，<code>er\b</code>可以匹配”never” 中的”er”，但不能匹配 “verb” 中的”er”。</td>
</tr>
<tr>
<td align="center"><code>\B</code></td>
<td align="left">匹配非单词边界。<code>er\B</code>能匹配”verb”中的”er”，但不能匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="center"><code>\d</code></td>
<td align="left">匹配一个数字字符。等价于<code>[0-9]</code>。</td>
</tr>
<tr>
<td align="center"><code>\D</code></td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td align="center"><code>\w</code></td>
<td align="left">匹配字母、数字、下划线。等价于<code>[A-Za-z0-9_]</code>。</td>
</tr>
<tr>
<td align="center"><code>\W</code></td>
<td align="left">匹配非字母、数字、下划线。等价于<code>[^A-Za-z0-9_]</code>。</td>
</tr>
<tr>
<td align="center"><code>\xn</code></td>
<td align="left">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\x41</code>匹配”A”。<code>\x041</code>则等价于’\x04’&amp;”1”。正则表达式中可以使用ASCII编码。</td>
</tr>
<tr>
<td align="center"><code>\s</code></td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[\f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td align="center"><code>\S</code></td>
<td align="left">匹配任何非空白字符。等价于<code>[^\f\n\r\t\v]</code>。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<strong>注意</strong>：shell里用grep时，<code>|</code>、<code>()</code>、<code>{}</code>、<code>+</code>、<code>?</code>需要转义。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -1 | grep <span class="string">'test_1\&#123;2\&#125;'</span></span></span><br><span class="line">test_11.sh</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的<code>{</code>和<code>}</code>前面要加<code>\</code>转义。</p>
<h1 id="表达式运算"><a href="#表达式运算" class="headerlink" title="表达式运算"></a>表达式运算</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>&emsp;&emsp;shell里的运算符基本跟c语言的一样</p>
<ul>
<li>基本运算符：+、-、*、/(加减乘除)、%(取模)</li>
<li>逻辑运算符：&amp;&amp;、||、!(与或非)</li>
<li>位运算符：&amp;(与)、|(或)、^(异或)、~(取反)、&lt;&lt;(位左移)、&gt;&gt;(位右移)</li>
<li>赋值运算符：=、+=、*=、/=、%=、&amp;=、|=、^|、&lt;&lt;=、…..</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>&emsp;&emsp;shell里用<code>$[表达式]</code>表示中括号里的是表达式，也可以用<code>$((表达式))</code>来表示，推荐使用中括号的形式。<br>&emsp;&emsp;<strong>注意</strong>：shell里只能对整形变量进行表达式运算，不能对字符串类型的变量进行表达式运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> -i VAR1=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> -i VAR2=111</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $[VAR1 + VAR2]</span></span><br><span class="line">234</span><br></pre></td></tr></table></figure>

<h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2><p>&emsp;&emsp;也可以用expr命令来进行表达式运算，expr命令支持的运算符有：|、&amp;、&lt;、&lt;=、=、!=、&gt;=、+、-、*、/、%。语法：<code>expr 表达式</code>，举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> expr 123 + 111  <span class="comment"># 加法运算</span></span></span><br><span class="line">234</span><br><span class="line"><span class="meta">$</span><span class="bash"> VAR1=333</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> VAR2=234</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> expr <span class="variable">$&#123;VAR1&#125;</span> - <span class="variable">$&#123;VAR2&#125;</span>  <span class="comment"># 变量１减变量２</span></span></span><br><span class="line">99</span><br><span class="line"><span class="meta">$</span><span class="bash"> expr <span class="variable">$&#123;VAR1&#125;</span> \* <span class="variable">$&#123;VAR2&#125;</span>  <span class="comment"># 变量１乘变量２</span></span></span><br><span class="line">77922</span><br><span class="line"><span class="meta">$</span><span class="bash"> expr <span class="variable">$&#123;VAR1&#125;</span> / <span class="variable">$&#123;VAR2&#125;</span>  <span class="comment"># 变量１除变量２</span></span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>注意</strong>：运算符两边都有一个空格。部分运算符前面要加个<code>\</code>来转义，比如*、&amp;、(、&gt;。<br>&emsp;&emsp;还可以用小括号来组成更复杂的表达式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> expr 12 \* \( 34 - 26 \)  <span class="comment"># 乘号和小括号前都要加\</span></span></span><br><span class="line">96</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> -i VAR1=413</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">declare</span> -i VAR2=34</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> expr <span class="variable">$&#123;VAR1&#125;</span> % \( <span class="variable">$&#123;VAR2&#125;</span> - 21 \) </span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;expr还可以进行简单的字符串运算，支持的有：</p>
<ul>
<li><strong>字符串 : 正则表达式</strong>： 在字符串中由给定正则表达式决定的锚定模式匹配。</li>
<li><strong>match 字符串 正则表达式</strong>：与“字符串 : 正则表达式”相同。</li>
<li><strong>substr 字符串 位置 长度</strong>：从某个位置开始，截取指定长度的子串，位置由 1 开始计数。</li>
<li><strong>index 字符串 字符</strong>：字符串中第一次出现指定字符的位置，如果不存在该字符，则输出0。</li>
<li><strong>length 字符串</strong>：字符串的长度。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> expr substr <span class="string">'this is a test'</span> 2 8</span></span><br><span class="line">his is a</span><br><span class="line"><span class="meta">$</span><span class="bash"> expr length <span class="string">'this is a test'</span></span></span><br><span class="line">14</span><br><span class="line"><span class="meta">$</span><span class="bash"> expr index <span class="string">'this is a test'</span> s</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;expr命令会将计算结果输出到标准输出，如果想将结果保存到变量里，可以用反引号来实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR=`expr 23 \* 42`</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR&#125;</span></span></span><br><span class="line">966</span><br></pre></td></tr></table></figure>

<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>&emsp;&emsp;shell里可以用test命令进行条件判断。语法：<code>test 表达式</code>或者<code>[ 表达式 ]</code>(注意这里中括号和表达式之间的空格不能省)。<br>&emsp;&emsp;可以通过查看变量$?的值，来判断表达式是否成立，如果成立，test命令返回值为0，变量$?的值也是0，如果不成立，则值为非0。test命令可以进行的条件判断包括以下几种。</p>
<h2 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h2><ul>
<li><strong>-z 字符串</strong>：字符串的长度为 0</li>
<li><strong>-n 字符串</strong>：字符串长度非零</li>
<li><strong>字符串</strong>：等价于<code>-n 字符串</code></li>
<li><strong>字符串1 = 字符串2</strong>：字符串相等</li>
<li><strong>字符串1 != 字符串2</strong>：字符串不相等</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR=<span class="string">''</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -z <span class="variable">$&#123;VAR&#125;</span> ] <span class="comment"># 判断字符串$&#123;VAR&#125;长度是否为0</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?  <span class="comment"># 查看test命令的返回值</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta">$</span><span class="bash"> VAR=<span class="string">'abc'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -z <span class="variable">$&#123;VAR&#125;</span> ]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="variable">$&#123;VAR&#125;</span> = <span class="string">'abc'</span> ] <span class="comment"># 判断字符串$&#123;VAR&#125;是否等于'abc'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="variable">$&#123;VAR&#125;</span> = <span class="string">'123'</span> ]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h2><ul>
<li><strong>整数1 -eq 整数2</strong>：整数1与整数2相等</li>
<li><strong>整数1 -ge 整数2</strong>：整数1大于或等于整数2</li>
<li><strong>整数1 -gt 整数2</strong>：整数1大于整数2</li>
<li><strong>整数1 -le 整数2</strong>：整数1小于或等于整数2</li>
<li><strong>整数1 -lt 整数2</strong>：整数1小于整数2</li>
<li><strong>整数1 -ne 整数2</strong>：整数1和整数2不相等</li>
</ul>
<h2 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h2><ul>
<li><strong>-e 文件</strong>：文件存在</li>
<li><strong>-d 文件</strong>：文件存在且为目录</li>
<li><strong>-f 文件</strong>：文件存在且为普通文件</li>
<li><strong>-r 文件</strong>：文件存在且有可读权限</li>
<li><strong>-w 文件</strong>：文件存在且有可写权限</li>
<li><strong>-x 文件</strong>：文件存在且有可执行（或搜索）权限</li>
<li><strong>-b 文件</strong>：文件存在且为块特殊文件</li>
<li><strong>-c 文件</strong>：文件存在且为字符特殊文件</li>
<li><strong>-g 文件</strong>：文件存在且被设置了 set-group-ID 位</li>
<li><strong>-g 文件</strong>：文件存在且为有效组ID 所有</li>
<li><strong>-h 文件</strong>：文件存在且为一个符号链接（与 -L 相同）</li>
<li><strong>-L 文件</strong>：文件存在且为一个符号链接（与 -h 相同）</li>
<li><strong>-k 文件</strong>：文件存在且被设置粘着位</li>
<li><strong>-O 文件</strong>：文件存在且为有效用户ID 所有</li>
<li><strong>-p 文件</strong>：文件存在且为命名管道</li>
<li><strong>-s 文件</strong>：文件存在且其大小大于零</li>
<li><strong>-S 文件</strong>：文件存在且为套接字</li>
<li><strong>-u 文件</strong>：文件存在且被设置了 set-user-ID 位</li>
<li><strong>-t FD</strong>：文件描述符 FD 在某个终端打开</li>
<li><strong>文件1 -ef 文件2</strong>：文件1 和文件2 拥有相同的设备编号与 inode 编号</li>
<li><strong>文件1 -nt 文件2</strong>：文件1 在修改时间上新于文件2</li>
<li><strong>文件1 -ot 文件2</strong>：文件1 比文件2 更旧</li>
</ul>
<h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><ul>
<li><strong>! 表达式</strong>：表达式为假</li>
<li><strong>表达式1 -a 表达式2</strong>：表达式1 与表达式2 皆为真</li>
<li><strong>表达式1 -o 表达式2</strong>：表达式1 或表达式2 为真</li>
</ul>
<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>&emsp;&emsp;直接上语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if 条件1</span><br><span class="line">then</span><br><span class="line">	条件1成立时执行的命令</span><br><span class="line">elif 条件2</span><br><span class="line">then</span><br><span class="line">	条件1不成立，且条件2成立时执行的命令</span><br><span class="line">else</span><br><span class="line">	条件1和条件2都不成立时执行的命令</span><br><span class="line">fi # 结束if语句</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的条件一般是一条shell命令，比如<code>test</code>、<code>gcc</code>等。如果命令的返回值为0，则条件成立。<br>&emsp;&emsp;小实验：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat shell.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">if [ $&#123;1&#125; -gt $&#123;2&#125; ]  # 判断$&#123;1&#125;是否大于$&#123;2&#125;</span><br><span class="line">then</span><br><span class="line">	echo 'num_1 &gt; num_2'</span><br><span class="line">elif [ $&#123;1&#125; -eq $&#123;2&#125; ]  # 判断$&#123;1&#125;是否等于$&#123;2&#125;</span><br><span class="line">then</span><br><span class="line">	echo 'num_1 = num_2'</span><br><span class="line">else</span><br><span class="line">	echo 'num_1 &lt; num_2'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shell.sh 12 12</span></span><br><span class="line">num_1 = num_2</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shell.sh 12 11</span></span><br><span class="line">num_1 &gt; num_2</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shell.sh 12 13</span></span><br><span class="line">num_1 &lt; num_2</span><br></pre></td></tr></table></figure>

<h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>&emsp;&emsp;语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case 字符串 in</span><br><span class="line">模式1)</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 模式1能匹配字符串时执行的命令</span></span><br><span class="line">	;; # 表示结束</span><br><span class="line">模式2)</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 模式2能匹配字符串时执行的命令</span></span><br><span class="line">	;; # 结束</span><br><span class="line">*)</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 以上模式都不匹配时执行的命令</span></span><br><span class="line">	;; # 结束</span><br><span class="line">esac # 结束case语句</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;case语句只能对字符串进行判断，这里的模式是指正则表达式。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>&emsp;&emsp;语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for VAR in item1 item2 .... itemN</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 循环内的命令</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat shell.sh </span></span><br><span class="line"></span><br><span class="line">for VAR in aaa bbb ccc</span><br><span class="line">do</span><br><span class="line">	echo $&#123;VAR&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash shell.sh </span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后再介绍几种shell里与for语句搭配使用的形式。</p>
<ol>
<li><p><code>{s..e}</code>：用来生成从s到e的序列，s和e可以是整数，也可以是大小写字母。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;-3..12&#125;</span></span><br><span class="line">-3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;a..z&#125;</span></span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里要注意的是，s和e中间有<strong>两个</strong>点，多一个或少一个都不行。<br>&emsp;&emsp;如果s和e是整数的话，可以在s和e前面加0，达到自动用0补全的效果，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;001..012&#125;</span></span><br><span class="line">001 002 003 004 005 006 007 008 009 010 011 012</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个和for循环搭配使用，就可以从s循环到e了，举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat shell.sh </span></span><br><span class="line"></span><br><span class="line">for i in &#123;01..04&#125;</span><br><span class="line">do</span><br><span class="line">	echo "str_$&#123;i&#125;"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash shell.sh </span></span><br><span class="line">str_01</span><br><span class="line">str_02</span><br><span class="line">str_03</span><br><span class="line">str_04</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>`命令`</code>或者<code>$(命令)</code>：用for语句来循环shell命令的输出，下面的例子用for语句输出当前目录的所有文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for FILE_NAME in `ls`</span><br><span class="line">do</span><br><span class="line">	echo $&#123;FILE_NAME&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里再重点介绍一下seq命令，seq命令也是用来生成序列的，与<code>{s..e}</code>不同的是，seq可以生成浮点数序列，但是不能生成大小写字母序列，用法有三种，如下：</p>
</li>
</ol>
<ul>
<li>seq [选项]… 尾数</li>
<li>seq [选项]… 首数 尾数</li>
<li>seq [选项]… 首数 增量 尾数</li>
</ul>
<p>&emsp;&emsp;首数默认是1，增量默认也是1，可用的选项有三个：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>指定生成的序列中每个数字的格式，指定方式和c语言的printf函数方式相同，<br>比如<code>%2.1f</code>，要注意的是只能用<code>%f</code>，<code>%d</code>和<code>%lf</code>都不行。</td>
</tr>
<tr>
<td>-s</td>
<td>指定分隔数字的字符串，默认是换行<code>\n</code>。</td>
</tr>
<tr>
<td>-w</td>
<td>通过填充前导零来均衡宽度，这个不能和<code>-f</code>同时使用。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;一些例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seq 3 <span class="comment"># 只有一个数字的，生成从1到该数字的序列，默认增量是1</span></span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">' '</span> 12  <span class="comment"># 用空格来分隔数字</span></span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">' '</span> -3 12  <span class="comment"># 有两个数字的，生成两个数字之间增量为1的序列</span></span></span><br><span class="line">-3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">' '</span> -3 0.8 12 <span class="comment"># 三个数字的</span></span></span><br><span class="line">-3.0 -2.2 -1.4 -0.6 0.2 1.0 1.8 2.6 3.4 4.2 5.0 5.8 6.6 7.4 8.2 9.0 9.8 10.6 11.4</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">'__'</span> -3 12  <span class="comment"># 用'__'来分隔数字</span></span></span><br><span class="line">-3__-2__-1__0__1__2__3__4__5__6__7__8__9__10__11__12</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">' '</span> -w -3 12  <span class="comment"># 通过填充前导零来均衡宽度</span></span></span><br><span class="line">-3 -2 -1 00 01 02 03 04 05 06 07 08 09 10 11 12</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq -s <span class="string">' '</span> -f %05.2f 12  <span class="comment"># 指定数字的格式</span></span></span><br><span class="line">01.00 02.00 03.00 04.00 05.00 06.00 07.00 08.00 09.00 10.00 11.00 12.00</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;seq与for语句搭配使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat shell.sh </span></span><br><span class="line"></span><br><span class="line">for i in `seq -3 12`</span><br><span class="line">do</span><br><span class="line">	echo -n "$&#123;i&#125; "</span><br><span class="line">done</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash shell.sh </span></span><br><span class="line">-3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后一种是for语句和路径通配符，举个栗子：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat shell.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用<span class="keyword">for</span>语句输出当前目录下的所有文件</span></span><br><span class="line">for FILE_NAME in ./*</span><br><span class="line">do</span><br><span class="line">	echo -n "$&#123;FILE_NAME&#125; "</span><br><span class="line">done</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash shell.sh </span></span><br><span class="line">./a.out ./in.txt ./out.txt ./shell.sh ./test.cpp</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>&emsp;&emsp;语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while 条件测试</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 循环内的命令</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;while语句首先进行条件测试，如果条件为真，则进入循环，直到条件为假时退出循环，跟C语言的一样。while语句的一个经典的用法是搭配输入重定向，读取文件的内容，下面是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while read VAR # 读取标准输入的一行</span><br><span class="line">do</span><br><span class="line">	echo $&#123;VAR&#125;</span><br><span class="line">done &lt; in.txt # 将in.txt文件重定向到标准输入</span><br></pre></td></tr></table></figure>

<h2 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h2><p>&emsp;&emsp;语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until 条件测试</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 循环内的命令</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;until语句在条件为假时进入循环，条件为真时退出循环，其他和while语句相同。</p>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>&emsp;&emsp;find命令用于查找文件，这里简单的列出一些常用的用法，更详细的用法可以查manpages。</p>
<h3 id="根据文件名查找"><a href="#根据文件名查找" class="headerlink" title="根据文件名查找"></a>根据文件名查找</h3><p>&emsp;&emsp;语法<code>find 查找的路径 -name pattern</code>，查找文件名与<a href="#模式">模式</a>pattern相匹配的文件。比如查找当前目录下所有以’.sh’结尾的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -name "*.sh"</span><br></pre></td></tr></table></figure>

<h3 id="根据正则表达式查找"><a href="#根据正则表达式查找" class="headerlink" title="根据正则表达式查找"></a>根据正则表达式查找</h3><p>&emsp;&emsp;语法<code>find 查找的路径 -regex pattern</code>，查找文件名与<a href="#正则表达式">正则表达式</a>pattern相匹配的文件。比如查找当前目录下所有以’test’开头的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -regex '^\./test.*'</span><br></pre></td></tr></table></figure>

<h3 id="根据路径查找"><a href="#根据路径查找" class="headerlink" title="根据路径查找"></a>根据路径查找</h3><p>&emsp;&emsp;语法<code>find 查找的路径 -path pattern</code>，查找文件的完整路径与<a href="#模式">模式</a>pattern相匹配的文件。与<code>-name</code>的区别是<code>-name</code>不匹配文件所在的目录，举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find ./shell -name <span class="string">"*sh*"</span></span></span><br><span class="line">./shell</span><br><span class="line">./shell/test_1.sh</span><br><span class="line"><span class="meta">$</span><span class="bash"> find ./shell -path <span class="string">"*sh*"</span></span></span><br><span class="line">./shell</span><br><span class="line">./shell/stxw.txt</span><br><span class="line">./shell/test_1.sh</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用<code>-name</code>匹配文件’./shell/stxw.txt’时，只匹配文件名’stxw.txt’，因为’stxw.txt’和模式”*sh*“不匹配，所以不输出。使用<code>-path</code>匹配文件’./shell/stxw.txt’时，会匹配文件的完整路径’./shell/stxw.txt’，而’./shell/stxw.txt’和模式”*sh*“匹配成功。</p>
<h3 id="根据文件类型查找"><a href="#根据文件类型查找" class="headerlink" title="根据文件类型查找"></a>根据文件类型查找</h3><p>&emsp;&emsp;语法<code>find 查找的路径 -type c</code>，查找文件文件类型是c的文件，类型包括：</p>
<ul>
<li>b ：特殊块文件(缓冲的)</li>
<li>c ：特殊字符文件(不缓冲)</li>
<li>d ：目录</li>
<li>p ：命名管道(FIFO)</li>
<li>f ：普通文件</li>
<li>l ：符号链接</li>
<li>s ：套接字</li>
</ul>
<p>&emsp;&emsp;查找当前目录下的普通文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -type f</span><br></pre></td></tr></table></figure>

<h3 id="根据文件大小查找"><a href="#根据文件大小查找" class="headerlink" title="根据文件大小查找"></a>根据文件大小查找</h3><p>&emsp;&emsp;语法<code>find 查找的路径 -size n[单位]</code>，查找文件大小是n的文件，默认的单位是512字节的块，也可以使用其他单位，支持的单位有：</p>
<ul>
<li>b ：块(512字节)</li>
<li>c ：字节</li>
<li>w ：字(2字节)</li>
<li>k ：千字节</li>
<li>M ：兆字节</li>
<li>G ：千兆字节</li>
</ul>
<p>&emsp;&emsp;还可以在n前面加个加号和减号，加个加号表示查找文件大小大于n的文件，减号表示小于，如果不加的话则查找文件大小刚好等于n的文件。举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下文件大小等于8个块的文件</span></span><br><span class="line">find ./ -size 8b</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下文件大小大于100千字节的文件（不包括等于100千字节的文件）</span></span><br><span class="line">find ./ -size +100k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下文件大小小于10兆的文件（不包括等于10M的文件）</span></span><br><span class="line">find ./ -size -10M</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里还有一个要注意的细节是，n必须是整数，所以低阶单位换算成高阶单位要向上取整，比如某个大小为70字节的文件，换算成块是70÷512=0.13671875块，但是用块来查找的时候，find命令将这个文件大小当做等于1个块来处理。</p>
<h3 id="根据时间查找"><a href="#根据时间查找" class="headerlink" title="根据时间查找"></a>根据时间查找</h3><p>&emsp;&emsp;语法：<code>find 查找的路径 -[时间类型][时间单位] n</code>，参数的关键字由时间类型和时间单位组成，时间类型包括三种：</p>
<ul>
<li>访问时间 ：对文件的最后一次的访问时间，用a表示。</li>
<li>修改时间 ：文件数据最后一次的修改时间，用m表示。</li>
<li>变化时间 ：文件状态(例如权限、所有者等)最后一次修改时间，用c表示。</li>
</ul>
<p>时间单位支持两种：</p>
<ul>
<li>min ：分钟</li>
<li>time ：24个小时</li>
</ul>
<p>将三种时间类型和两种时间单位组合，可以产生6种参数：</p>
<ul>
<li>-amin n ：对文件的最后一次的访问时间是在n分钟之前。</li>
<li>-atime n ：对文件的最后一次的访问时间是在n×24小时之前。</li>
<li>-mmin n ：文件数据最后一次的修改时间是在n分钟之前。</li>
<li>-mtime n ：文件数据最后一次的修改时间是在n×24小时之前。</li>
<li>-cmin n ：文件状态最后一次修改时间是在n分钟之前。</li>
<li>-ctime n ：文件状态最后一次修改时间是在n×24小时之前。</li>
</ul>
<p>&emsp;&emsp;举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，最后一次的访问是在5分钟之前的文件。</span></span><br><span class="line">find ./ -amin 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件数据最后一次的修改时间是在2×24小时之前的文件。</span></span><br><span class="line">find ./ -mtime 2</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果n前面加个负号，则查找的是对应时间离现在不超过n的文件，举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，最后一次的访问时间离现在不超过5分钟的文件。</span></span><br><span class="line">find ./ -amin -5</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还可以以某个文件的最后一次修改时间作为参照，来查找文件。</p>
<ul>
<li>-anewer file ：对文件的最后一次访问时间在file的最后一次修改时间之后。</li>
<li>-newer file ：文件数据最后一次的修改时间在file的最后一次修改时间之后。(注意这里前面不要加m)</li>
<li>-cnewer file ：文件状态最后一次修改时间在file的最后一次修改时间之后。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，最后一次的访问时间在./test.sh文件的最后一次修改时间之后的文件。</span></span><br><span class="line">find ./ -anewer ./test.sh</span><br></pre></td></tr></table></figure>

<h3 id="根据文件所有者查找"><a href="#根据文件所有者查找" class="headerlink" title="根据文件所有者查找"></a>根据文件所有者查找</h3><p>参数：</p>
<ul>
<li>-user uname ：文件的所有者是uname(也可以使用数字形式的用户ID)。</li>
<li>-group gname ：文件属于gname(也允许使用数字形式的组ID)群组。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件所有者是root的文件。</span></span><br><span class="line">find ./ -user root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件所在群组为root的文件。</span></span><br><span class="line">find ./ -group root</span><br></pre></td></tr></table></figure>

<h3 id="根据权限查找"><a href="#根据权限查找" class="headerlink" title="根据权限查找"></a>根据权限查找</h3><ul>
<li>-perm mode ：文件的权限位恰好是mode(八进制或符号)。</li>
<li>-perm -mode ：mode中的所有的权限位都被设置了的文件。</li>
<li>-perm +mode ：mode中的任意一个的权限位被设置了的文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，权限是0777的文件。</span></span><br><span class="line">find ./ -perm 0777</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件所有者既有可写，又有可执行权限的文件。</span></span><br><span class="line">find ./ -perm -0300</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件所有者有可写，或者有可执行权限的文件。</span></span><br><span class="line">find ./ -perm +0300 # 这条命令会报错“find: 非法权限 ‘+0300’”，不知道为什么</span><br></pre></td></tr></table></figure>

<h3 id="多条件查找"><a href="#多条件查找" class="headerlink" title="多条件查找"></a>多条件查找</h3><p>&emsp;&emsp;可以用与或非逻辑，查找满足多种条件的命令。</p>
<ul>
<li>!或-not ：查找不满足条件的文件。</li>
<li>-a或-and ：查找两个条件都满足的文件。(默认的条件连接逻辑)</li>
<li>-o或-or ：查找满足任意一个条件的文件。</li>
</ul>
<p>&emsp;&emsp;举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，除文件目录外的所有文件</span></span><br><span class="line">find ./ ! -type d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，文件大小在2M到100M之间的文件</span></span><br><span class="line">find ./ -size +2M -and -size -100M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，以.png或.jpg结尾的文件</span></span><br><span class="line">find ./ -name "*.png" -or -name "*.jpg"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;逻辑运算的优先级是“! &gt; -not &gt; 缺省与 &gt; -a &gt; -and &gt; -o &gt; -or”。如果要提高运算的优先级，可以用小括号括起来。举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下，以.png或.jpg结尾，且大小大于1M的文件</span></span><br><span class="line">find ./ \( -name "*.png" -or -name "*.jpg" \) -and -size +1M</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的命令中，如果不加扩号，会先进行与运算，再进行或运算。加了括号以后，则优先进行括号里的或运算，再进行与运算。<br>&emsp;&emsp;要注意的是两个括号前面要加<code>\</code>转义，而且前后都要用空格和其他参数分开。</p>
<h3 id="找到文件后执行命令"><a href="#找到文件后执行命令" class="headerlink" title="找到文件后执行命令"></a>找到文件后执行命令</h3><p>&emsp;&emsp;find命令可以用<code>-exec</code>和<code>-ok</code>参数，在找到的文件后执行特定的命令。举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下以.sh结尾的文件，并将找到的文件移动到./shell/目录下</span></span><br><span class="line">find ./ -name "*.sh" -exec mv &#123;&#125; ./shell/ \;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述命令中，<code>{}</code>表示找到的文件，<code>\;</code>表示命令的结束。<br>&emsp;&emsp;find命令中，<code>-exec</code>和<code>-ok</code>的区别是，使用<code>-ok</code>在每次执行命令前会进行确认是否执行，<code>-exec</code>则直接执行，不确认。<br>&emsp;&emsp;如果在对找到的文件要执行多条命令，可以使用多次<code>-exec</code>或<code>-ok</code>，举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下的文件输出两遍</span></span><br><span class="line">find ./ -exec echo &#123;&#125; \; -exec echo &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1067 Gap</title>
    <url>/acm/hdu-1067/</url>
    <content><![CDATA[<p>广度优先搜索＋map标记状态</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1067" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1067</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>&emsp;&emsp;首先给出28（4×7）张卡片和一个4×8的表格，每张卡片都有一个数字，分别是11～17、21～27、31～37和41～47。初始时将卡片随机放入表格里除第一列以外的其他位置，如下图：<br><img src="/images/acm/hdu-1067/1582445042932.gif" alt=""><br>然后将数字11的卡片放到第一列的第一行，数字21的卡片放到第一列的第二行，数字31和41的卡片类似，如下图：<br><img src="/images/acm/hdu-1067/1582445276370.gif" alt=""><br>接下来需要移动卡片，移动的规则是，只能将卡片移动到空白格子上，且移动到空白格子上的卡片，必须是比空白格子左边卡片上的数字大1的那张。比如上图的第一行的第二列空白格子，其左边卡片上的数字是42，那么只能将数字为43的卡片移动到该空白格子上。在移动过若干次卡片后，如果卡片的位置能变成下图所示的样子，输出最小移动的次数，否则输出-1。<br><img src="/images/acm/hdu-1067/1582446099263.gif" alt=""></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>&emsp;&emsp;这题要计算最小移动的次数，首先想到的是用广度优先搜索，比较麻烦的是标记每次移动后状态。可以将表格的状态转化为一个长度为28的字符串（4×7，表格第一列不会被移动，所以不用标记），然后用map的这个字符串来判断该状态是否被标记过。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> index[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, si, di, dnum;</span><br><span class="line">	node tep;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; mp;</span><br><span class="line">	<span class="keyword">char</span> end[<span class="number">30</span>] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(start.a, end) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	que.push(start);</span><br><span class="line">	mp[start.a] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(que.empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			tep = que.front();</span><br><span class="line">			si = tep.index[k];</span><br><span class="line">			dnum = (si % <span class="number">7</span> == <span class="number">0</span>) ? si / <span class="number">7</span> * <span class="number">10</span> + <span class="number">12</span> : tep.a[si - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(dnum == <span class="number">2</span> || dnum % <span class="number">10</span> == <span class="number">8</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">28</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(tep.a[i] == dnum)</span><br><span class="line">				&#123;</span><br><span class="line">					di = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tep.a[di] = <span class="number">1</span>;</span><br><span class="line">			tep.a[si] = dnum;</span><br><span class="line">			tep.index[k] = di;</span><br><span class="line">			tep.t++;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tep.a, end) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> tep.t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mp.count(tep.a) == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mp[tep.a] = <span class="literal">true</span>;</span><br><span class="line">			que.push(tep);</span><br><span class="line">		&#125;</span><br><span class="line">		que.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, i, j, k, ans, in;</span><br><span class="line">	node start;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in);</span><br><span class="line">				start.a[i * <span class="number">7</span> + j] = (<span class="keyword">char</span>)in;</span><br><span class="line">				<span class="keyword">if</span>(start.a[i * <span class="number">7</span> + j] % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					start.a[i * <span class="number">7</span> + j] = <span class="number">1</span>;</span><br><span class="line">					start.index[k] = i * <span class="number">7</span> + j;</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		start.a[<span class="number">28</span>] = <span class="string">'\0'</span>;</span><br><span class="line">		start.t = <span class="number">0</span>;</span><br><span class="line">		ans = solve(start);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hdu</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>装的第一台电脑</title>
    <url>/live/assemble_computer/</url>
    <content><![CDATA[<h1 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h1><p>&emsp;&emsp;前阵子因为大学用的小米笔记本屏幕坏了，所以买了个2K的显示器，外接给笔记本用。虽然日常用起来不卡，不过笔记本摸起来很烫，风扇经常呼啦呼啦地转，可能是盖起盖子影响了散热，也可能是以笔记本的性能带个2K显示器有点吃力，毕竟是个轻薄本吗。总之，我是迫不得已才剁手买电脑的，绝对不是因为笔记本打游戏太卡了的原因。</p>
<h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><table>
<thead>
<tr>
<th align="left">电脑配件</th>
<th align="left">型号</th>
<th align="left">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpu</td>
<td align="left">AMD 3600x</td>
<td align="left">￥1366</td>
</tr>
<tr>
<td align="left">显卡</td>
<td align="left">还没买到</td>
<td align="left">￥105</td>
</tr>
<tr>
<td align="left">主板</td>
<td align="left">华硕重炮手B550M(带wifi)</td>
<td align="left">￥739</td>
</tr>
<tr>
<td align="left">内存</td>
<td align="left">金士顿骇客神条3600，8G×2</td>
<td align="left">￥689</td>
</tr>
<tr>
<td align="left">电源</td>
<td align="left">酷冷至尊sfx 650w</td>
<td align="left">￥878</td>
</tr>
<tr>
<td align="left">硬盘</td>
<td align="left">三星970 EVO Plus 500G + 西部数据SN550 1T</td>
<td align="left">￥649 + ￥749</td>
</tr>
<tr>
<td align="left">机箱</td>
<td align="left">酷鱼s5</td>
<td align="left">￥300</td>
</tr>
<tr>
<td align="left">散热器</td>
<td align="left">乔思伯CR-1400</td>
<td align="left">￥79</td>
</tr>
<tr>
<td align="left">风扇</td>
<td align="left">利民TL-C12S×2 + 乔思伯FR925×3</td>
<td align="left">￥179.8 +￥89.7</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">￥5823.5</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;趁着双11降价，除了显卡外（显卡涨地飞起，想再等等），其他电脑配件都买到了。第一次配电脑，瞎买的，感觉没配好，然后因为配的是itx电脑，所以性价比比较低。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电脑</tag>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>新买的捷安特ATX830自行车</title>
    <url>/live/new_bicycle_ATX830/</url>
    <content><![CDATA[<h1 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h1><p>&emsp;&emsp;很久以前就想买一辆自行车了，奈何<del>没钱</del>家境贫寒，一直没买，前段时间坐公交上班的时候，经常因为堵车迟到，所以就决定去买一辆来代步。本来想买辆便宜点的喜德盛，后来被某有钱人<del>建议</del>怂恿，就选了捷安特。<br>&emsp;&emsp;昨天去专卖店里买的，买这种品牌自行车还是去正规专卖店好，以后可以免费保养，售后会好一点。我对自行车不太懂，因为是用来上下班，店长就向我推荐了两款，ATX810和ATX830。考虑到ATX810飞轮是8速的（店长说9速的稳定性比8速的好很多），而且这两款价格相差不太大，所以最终选这款ATX830，价格￥2489，它的详细配置如下。</p>
<table>
<thead>
<tr>
<th align="left">部件</th>
<th align="left">型号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">车架</td>
<td align="left">GIANT ATX8 ALUXX铝合金车架</td>
</tr>
<tr>
<td align="left">前叉</td>
<td align="left">铝合金线控锁死避震前叉</td>
</tr>
<tr>
<td align="left">车把</td>
<td align="left">GIANT 31.8铝合金直把</td>
</tr>
<tr>
<td align="left">车首竖杆</td>
<td align="left">铝合金竖杆</td>
</tr>
<tr>
<td align="left">座垫杆</td>
<td align="left">铝合金座垫杆</td>
</tr>
<tr>
<td align="left">座垫</td>
<td align="left">GIANT运动座垫</td>
</tr>
<tr>
<td align="left">变速把手</td>
<td align="left">标配小副把</td>
</tr>
<tr>
<td align="left">前变速器</td>
<td align="left">27S</td>
</tr>
<tr>
<td align="left">后变速器</td>
<td align="left">27S</td>
</tr>
<tr>
<td align="left">刹车</td>
<td align="left">油压碟刹</td>
</tr>
<tr>
<td align="left">大齿盘</td>
<td align="left">锻造铝腿22/30/40T大齿盘</td>
</tr>
<tr>
<td align="left">轮胎</td>
<td align="left">GIANT QUICKCROSS 27.5x1.95 30TPI山地轮胎</td>
</tr>
<tr>
<td align="left">轮组</td>
<td align="left">GAINT 双层铝合金轮圈 + GIANT 铝合金培林花鼓</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;店里有3种颜色选择，橙色、黑色和灰色，个人不喜欢灰色，橙色也不是很喜欢的颜色，<del>如果有粉色就好了</del>，最终选了黑色，整体的样子就是下面这张图片的样子。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2892.JPG" alt=""></p>
<h1 id="车架"><a href="#车架" class="headerlink" title="车架"></a>车架</h1><p>&emsp;&emsp;型号是<code>GIANT ATX8 ALUXX铝合金车架</code>，这个是ALUXX是捷安特的铝合金车架成型技术，网上说是入门级的，更高端的还有ALUXX SL和ALUXX SLR，貌似比ALUXX更轻一点。整体感觉不重，但也不算轻，铝合金的车架要比碳纤维的稍微重一点，车架是内走线的，刹车线从车架里面传到变速器和后刹车。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2894.JPG" alt=""></p>
<h1 id="前叉"><a href="#前叉" class="headerlink" title="前叉"></a>前叉</h1><p>&emsp;&emsp;这个前叉应该是前面减震的这个东西，这款是可以用线控器锁住减震的，店长说上坡的时候锁住会好骑一点。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2889.JPG" alt=""></p>
<h1 id="车把和车首竖杆"><a href="#车把和车首竖杆" class="headerlink" title="车把和车首竖杆"></a>车把和车首竖杆</h1><p>&emsp;&emsp;都是铝合金的，车把有副把，如果路况比较好，不怎么刹车的话，可以用副把来骑，减轻手腕的酸痛。车把上左右各一个变速器和刹车器，还有锁住前叉的线控器和铃铛。</p>
<p><img src="/images/live/new_bicycle_ATX830/handlebar.JPG" alt=""></p>
<h1 id="刹车"><a href="#刹车" class="headerlink" title="刹车"></a>刹车</h1><p>&emsp;&emsp;油压碟刹的，比机械碟刹的好一点，具体不太懂，店长说刹车的碟片来令片不能碰到油，会影响刹车的制动力。</p>
<h1 id="大齿盘"><a href="#大齿盘" class="headerlink" title="大齿盘"></a>大齿盘</h1><p>&emsp;&emsp;锻造铝腿22/30/40T大齿盘。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2882.JPG" alt=""></p>
<h1 id="飞轮"><a href="#飞轮" class="headerlink" title="飞轮"></a>飞轮</h1><p>&emsp;&emsp;9速的，不太懂，店长说骑的时候多变速可以减轻链条对飞轮片的磨损，增加自行车的使用寿命。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2878.JPG" alt=""></p>
<h1 id="轮组"><a href="#轮组" class="headerlink" title="轮组"></a>轮组</h1><p>&emsp;&emsp;轮组是自行车里比较重要的部分，我这款用的是<code>GAINT 双层铝合金轮圈 + GIANT 铝合金培林花鼓</code>，不太懂，对于我这种用来上下班的来说，应该算还不错吧。</p>
<h1 id="轮胎"><a href="#轮胎" class="headerlink" title="轮胎"></a>轮胎</h1><p>&emsp;&emsp;轮胎用的是27.5x1.95的，店长建议车胎内压力在40~60psi之间会好一点。</p>
<h1 id="座垫和座垫杆"><a href="#座垫和座垫杆" class="headerlink" title="座垫和座垫杆"></a>座垫和座垫杆</h1><p>&emsp;&emsp;座垫坐起来感觉还不错，座垫杆这里经过特殊处理，可以增加座垫杆和车架的摩擦，防止坐垫滑动。店长帮我在坐垫下面装了个尾灯，晚上骑行会安全一点。</p>
<p><img src="/images/live/new_bicycle_ATX830/IMG_2885.JPG" alt=""></p>
<h1 id="车锁"><a href="#车锁" class="headerlink" title="车锁"></a>车锁</h1><p>&emsp;&emsp;这个车锁是比较有意思的，见下图，店长说这个锁防液压剪，价格￥338感觉有点小贵。</p>
<p><img src="/images/live/new_bicycle_ATX830/lock.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;我个人感觉这辆车整体来说还不错，从店里到家一个骑了7公里多的路，没感觉到累，骑起来挺轻松的，自行车和各种配件一共￥3282。可惜天气预报显示这周会一直下雨，没法骑这这辆自行车去上班了，还是要坐公交，去淘宝上买个<del>浴衣</del>雨衣吧。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>自行车</tag>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title>End-to-End Latent Fingerprint Search</title>
    <url>/papers/End-to-End_Latent_Fingerprint_Search/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/End-to-End_Latent_Fingerprint_Search.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><p>&emsp;&emsp;所提出的潜在指纹搜索系统的设计和原型是[25]工作的一个显著改进版本。图2显示了提出系统的总体流程图。本文的主要贡献如下:</p>
<ul>
<li>一种基于自动编码器的潜在指纹增强算法，用于鲁棒准确地提取ROI、脊线流和脊线间距。</li>
<li>基于自动编码器的潜指纹细节点检测。</li>
<li>补充模板：三个细节点模板和一个纹理模板。这些模板是从大量的候选模板中选择出来的，以达到最佳的识别精度。</li>
<li>利用非线性映射减少细节点模板和纹理模板的描述符长度。为了提高计算效率，使用<code>产品量化</code>进一步减少了参考纹理模板的描述符。</li>
<li>潜指纹的搜索结果，在NIST SD27, MSP，和WVU潜指纹数据库上针对一个100K个滚动指纹的后台，表现出了最先进的性能。</li>
<li>在Intel(R) Xeon(R) CPU E5-2680 v3@2.50GHz上实现的多核解决方案，每次潜指纹与参考指纹比对需要~1ms。因此，对100K个参考指纹的潜指纹搜索可以在100秒内完成。在Intel(R) i7- 7780@4.00GHz(CPU)和GTX 1080 Ti(GPU)的机器上，潜指纹特征提取时间为~15秒。</li>
</ul>
<p><img src="/images/paper/End-to-End_Latent_Fingerprint_Search/fig_2.png" alt="" title="图2：端到端潜在识别系统概述。给定一个查询隐式，将生成三个细部模板和一个纹理模板。两个匹配器，即细部模板匹配器和纹理(虚拟细部)模板匹配器用于查询潜在打印和参考打印之间的比较"></p>
<h1 id="潜指纹预处理"><a href="#潜指纹预处理" class="headerlink" title="潜指纹预处理"></a>潜指纹预处理</h1><h2 id="通过自动编码器进行潜指纹增强"><a href="#通过自动编码器进行潜指纹增强" class="headerlink" title="通过自动编码器进行潜指纹增强"></a>通过自动编码器进行潜指纹增强</h2><p>&emsp;&emsp;我们提出了一个用于潜指纹增强的卷积自编码器。增强图像前需要找到对脊线质量、流和间距鲁棒并准确的估计。网络训练流程图如图3所示。</p>
<p><img src="/images/paper/End-to-End_Latent_Fingerprint_Search/fig_3.png" alt=""></p>
<p>&emsp;&emsp;由于没有由低质量和高质量指纹图像对组成的公开数据集来训练自动编码器，我们对2000张高质量的滚动指纹图像(NFIQ 2.0 value &gt; 70)进行退化，以创建用于训练的图像对。退化过程包括将指纹图像随机划分为128×128像素大小的重叠块，然后加入加性高斯噪声，进行参数为$\sigma(\sigma \in (5, 15))$高斯滤波。图4为一些高质量指纹块和其对应退化版本的例子。此外，采用了随机旋转、随机亮度和随机对比度变化等数据增强方法，提高了训练后的自编码器的鲁棒性。</p>
<p><img src="/images/paper/End-to-End_Latent_Fingerprint_Search/fig_4.png" alt=""></p>
<p>&emsp;&emsp;卷积自编码器包括一个编码器和一个解码器，如图3所示。编码器由5个卷积层组成，内核大小为4×4，步长为2。解码器由5个反卷积层(或转置卷积层)组成，内核大小为4×4，步长为2。激活函数ReLU(整流线性单元)在每一个卷积层或反卷积层之后使用，但最后一个输出层使用 <em>tanh</em> 函数。表1总结了卷积自编码器的结构。<br>&emsp;&emsp;在滚动指纹上训练的自动编码器不能很好地增强潜在指纹。因此，我们用潜指纹图像分解后的纹理成分，代替原始的潜指纹图像，输入到自动编码器中。图5(b)显示了与图5(a)中潜指纹图像对应的增强后的潜指纹图像。增强后的潜指纹图像的脊线清晰度明显高于输入的原始潜指纹图像。</p>
<p><img src="/images/paper/End-to-End_Latent_Fingerprint_Search/fig_5.png" alt=""></p>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>深度学习</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Fingerprint Minutiae Matching Based on the Local And Global Structures</title>
    <url>/papers/Fingerprint_Minutiae_Matching/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/Fingerprint_Minutiae_Matching_Based_on_the_Local_And_Global_Structures.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="Abstract（摘要）"><a href="#Abstract（摘要）" class="headerlink" title="Abstract（摘要）"></a>Abstract（摘要）</h1><p>&emsp;&emsp;本文提出了一种新的指纹细节点匹配技术，利用指纹细节点的局部结构和全局结构对指纹细节点进行匹配。细节点的局部结构描述了细节点在其邻域内的旋转平移不变特征。该算法用于寻找两个细节点集的对应关系，提高全局匹配的可靠性。指纹细节点的全局结构可靠地决定了指纹的唯一性。因此，局部和全局细节点结构共同为可靠鲁棒的细节点匹配提供了坚实的基础。所提出的细节点匹配方案由于处理速度快，适合于在线处理。实验结果表明了该方法的有效性。</p>
<h1 id="Introduction（介绍）"><a href="#Introduction（介绍）" class="headerlink" title="Introduction（介绍）"></a>Introduction（介绍）</h1><p>&emsp;&emsp;虽然存在一些基于图像和基于图的指纹匹配，但目前大多数要求处理速度快、模板尺寸小、安全性高的指纹验证系统都是基于细节点匹配的。这是因为人们普遍认为指纹的细节点是最具辨识力和最可靠的特征。与大多数自动指纹验证/识别系统一样，我们采用了两种最显著的细节点:脊线端点和脊线分叉点，这两种细节点是联邦调查局使用的，使用[11,12,15]中提出的技术可以很容易地通过计算机提取出来。</p>
<p>&emsp;&emsp;细节点的特征向量一般由细节点类型、坐标和细节点的切线角度组成。采用点模式匹配代替指纹图像匹配来实现指纹的自动验证/识别。文献[8-10]提出了几种点模式匹配算法。对这些算法的一些评价见[11,12]。由于模板的两个点集与输入指纹之间的对应关系是未知的，因此点模式匹配通常是一个棘手的问题。由于指纹的旋转、平移和变形、被检测细节点的位置和方向的误差、伪细节点的存在和真细节点的缺失等因素，难以获得细节点通信。</p>
<p>&emsp;&emsp;A. K. Jain等人在[11,12]中提出了一种基于对齐的匹配算法，利用与细节点相关联的脊线将输入的细节点与模板的细节点进行对齐，并提出了一种自适应弹性匹配算法来匹配对齐后的细节点。作者报告了良好的性能。然而，这种方法会导致较大的模板尺寸，因为必须保存每个细节点的相关脊线。如果只保存了较短的脊线，该算法可能会导致不准确的对齐，或者更糟的是，错误的对齐。A. K. Hrechak和J. A. Mchugh[13]提出了另一种完全不同的方法，使用细节点的局部结构来描述细节点的特征。该方法在处理速度和对旋转和部分打印的鲁棒性方面具有一定的优势。在[14]中提出了对该方法的一些改进。然而，局部结构是不那么明显的特征，因为它仅由细节点的一小部分决定。不同手指的指纹可能有很多相似的局部结构，而同一手指的指纹可能只有很少的相似结构，这是由于假细节点的存在和真细节点的缺失。因此，仅基于局部结构的指纹匹配可靠性较低。</p>
<p>&emsp;&emsp;本文提出了一种基于指纹局部结构和指纹全局结构的指纹匹配方法。在比较两个指纹时，由人类专家手动检查指纹的局部位置关系(即指纹的局部结构)，最后利用由整个指纹集组成的指纹唯一的全局位置结构进行验证。我们的方法试图自动化这种人类专家的行为。细节点的局部结构是旋转和平移不变的，因为它由相对于其他一些细节点的方向和位置组成。此外，由于局部结构是由指纹的一小块区域形成的，因此能够适应合理的变形。因此，局部结构可以直接用于匹配，而最佳匹配的局部结构提供了匹配细节点全局结构的对应关系。对的全局结构和局部结构匹配的结果最终决定两个指纹是否是由同一根手指生成的。</p>
<h1 id="Local-structure-matching（局部结构匹配）"><a href="#Local-structure-matching（局部结构匹配）" class="headerlink" title="Local structure matching（局部结构匹配）"></a>Local structure matching（局部结构匹配）</h1><p>&emsp;&emsp;通常，从指纹中检测出的一个细节点$M_k$可以用公式(1)给出的特征向量来描述。</p>
<p>$$ F_k = \left(x_k \ \  y_k \ \ \varphi_k \ \ t_k \right)^T, \tag{1} $$</p>
<p>其中$(x_k, y_k)$是$M_k$的坐标，$\varphi_k$是局部脊线方向，$t_k$是细节点的类型（脊线端点或分叉点）。尽管脊线方向的范围只有$(-\frac{\pi}{2}, \frac{\pi}{2}]$，但可以将细节点的方向可以定到范围$(-\pi, \pi]$，以增加其分辨力(见图1)。</p>
<p><img src="/images/paper/Fingerprint_Minutiae_Matching/fig_1.png" alt="" title="图1. 一个细节点的局部结构"></p>
<p>&emsp;&emsp;特征向量集<strong>F</strong>包含了从指纹中检测到的所有细节点的特征向量$F_k, k=1, 2, …N$，<strong>F</strong>决定了指纹的全局细节点结构。指纹细节点匹配是指在模板指纹和输入指纹的两个全局细节点结构之间寻找相似度。</p>
<p>&emsp;&emsp;为了简化我们算法的描述，我们定义一个函数$d\phi(t_1, t_2)$来表示两个方向或角度的差，$t_1$和$t_2$的范围是$-\pi &lt; t_1, t_2 \leq \pi$，如下所示：</p>
<p>$$<br>d\phi(t_1, t_2) =<br>\begin{cases}<br>    t_1 - t_2,            &amp; if\ \ -\pi &lt; t_1 - t_2 \leq \pi \\<br>    2\pi + (t_1 - t_2),    &amp; if\ \ t_1 - t_2 \leq -\pi \\<br>    2\pi - (t_1 - t_2),    &amp; if\ \ t_1 - t_2 \leq -\pi.<br>\end{cases} \tag{2}<br>$$</p>
<p>&emsp;&emsp;指纹细节点的$x_k$、$y_k$和$\varphi_k$的全局特征依赖于指纹的旋转和平移。因此，它不能直接用于匹配。然而，我们可以利用其邻域内的其他细节点来描述具有旋转和平移不变特征的细节点。对于每个细节点$M_k$，由公式(3)(4)(5)计算细节点$M_k$与其l近邻的细节点的相对距离$d_{ki}$，径向角$\theta_{ki}$和细节点方向$\varphi_{ki}$，这些属性与指纹的旋转和平移是无关的。</p>
<p>$$ d_{ki} = \sqrt{(x_k - x_i)^2 + (y_k, y_i)^2}, \tag{3} $$</p>
<p>$$ \theta_{ki} = d\phi\left( \tan^{-1} \left( \frac{y_k - y_i}{x_k - x_i} \right), \varphi_k \right), \tag{4} $$</p>
<p>$$ \varphi_{ki} = d\phi(\varphi_k, \varphi_i) \tag{5} $$</p>
<p>细节点的局部结构是通过细节点相对于每一个已知邻域细节点的距离、脊线数、方向和径向角以及这些细节点的类型来描述的，它描述的是细节点的旋转和平移。用$l$近邻(这里$l=2$)描述细节点$M_k$的局部结构特征的的特征向量为：</p>
<p>$$ Fl_k = \left(d_{ki}\ \ d_{kj}\ \ \theta_{ki}\ \ \theta_{kj}\ \ \varphi_{ki}\ \ n_{ki}\ \ n_{kj}\ \ t_k \right)^T, \tag{6} $$</p>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title>High-Performance Large-Scale Image Recognition Without Normalization</title>
    <url>/papers/High-Performance_Large-Scale_Image_Recognition/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/High-Performance_Large-Scale_Image_Recognition_Without_Normalization.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="Abstract（摘要）"><a href="#Abstract（摘要）" class="headerlink" title="Abstract（摘要）"></a>Abstract（摘要）</h1><p>&emsp;&emsp;批量归一化是大多数图像分类模型的关键组成部分，但由于其对批处理大小的依赖和实例之间的交互，它有许多不需要的特性。虽然最近的工作已经成功地训练了没有归一化层的深度重网络，但这些模型无法与最好的批归一化网络的测试精度竞争，而且对于大学习率或强数据增强通常不稳定。在这项工作中，我们开发了一种自适应梯度裁剪技术来克服这些不稳定性，并设计了一种显著改进的Normalizer-Free ResNets类。我们较小模型EfficientNet-B7的匹配测试准确率，在ImageNet上训练可以快8.7倍，我们最大的模型达到了新的最先进top-1准确率86.5%。此外，在对3亿张标记图像数据集进行大规模的预训练后，在ImageNet上进行微调时，无归一化模型获得了比批量归一化模型显著更好的性能，我们最好的模型获得了89.2%的准确率。</p>
<h1 id="Introduction（介绍）"><a href="#Introduction（介绍）" class="headerlink" title="Introduction（介绍）"></a>Introduction（介绍）</h1><p>&emsp;&emsp;最近计算机视觉中的绝大多数模型都是深度残差网络的变体，训练时经过了批量归一化处理。这两种架构创新的结合使从业者能够训练更深的网络，从而在训练集和测试集上获得更高的准确性。批归一化还可以平滑损失情况，这使得更大学习率和更大批量大小能稳定训练，而且它还有正则化的效果。但是，批处理规范化有三个显著的实际缺点：</p>
<ol>
<li>首先，它是一个非常昂贵的计算原语，这会导致内存开销，并显著增加了在一些网络中评估梯度所需的时间。</li>
<li>其次，它引入了模型在训练期间和推断时之间的行为差异，引入了需要调整的隐藏超参数。</li>
<li>第三，也是最重要的，批量归一化打破了小批量处理中训练样本之间的独立性。</li>
</ol>
<p>&emsp;&emsp;这三个特性有一系列的负面影响。例如，实践者发现批量归一化网络通常很难在不同的硬件上精确复制，而且批量归一化往往会导致微小的实现错误，特别是在分布式训练中。此外，批量归一化不能用于某些任务，因为批量中的训练样本之间的交互使网络能够“欺骗”某些损失函数。例如，批量归一化在一些对比学习算法中需要特别注意防止信息泄露。这也是序列建模任务的主要关注点，这促使语言模型采用替代归一化的方法。如果在训练过程中批量统计有较大的方差，则批量归一化网络的性能也会降低。最后，批量归一化的性能对批量大小很敏感，批量大小过小时批量归一化网络性能较差，这限制了我们在有限硬件上训练的最大模型尺寸。我们在附录B中扩展了与批量归一化相关的挑战。</p>
<p>&emsp;&emsp;因此，尽管批处理归一化使深度学习社区在最近几年取得了长足的进步，但我们预计，从长远来看，它可能会阻碍进步。我们相信社区应该寻找一种简单的替代方法，它可以实现具有竞争力的测试准确性，并可以用于广泛的任务。</p>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Segmentation and Enhancement of Latent Fingerprints: A Coarse to Fine Ridge Structure Dictionary</title>
    <url>/papers/Segmentation_and_Enhancement_of_Latent_Fingerprints/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/Segmentation_and_Enhancement_of_Latent_Fingerprints.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>&emsp;&emsp;潜在指纹(或简称“潜指纹”或“指印”)指的是某人在不小心触摸或手握过的物品表面上留下的指纹，通常出现在犯罪现场。与在参与模式下获得的滚动和平面指纹(或样本指纹)相比，潜在指纹的脊线结构通常质量较差，包含背景噪声和非线性失真(见图1)。由于这些因素的影响，潜指纹识别(潜指纹对样本匹配)的准确性远远低于样本指纹(样本对样本匹配)的准确性。作为一个例子，在上NIST评估，在10,000个平面指纹的后台数据库上，表现最好的自动指纹识别系统(AFIS)取得了99.4%的1级鉴定率；用1114个潜指纹在包含100,000个样本指纹后台数据库上，表现最好的商业潜指纹匹配器只能达到63.4%的1级鉴定率。图2显示了滚动到滚动指纹匹配和潜指纹到滚动指纹匹配的示例。在这些例子中，滚动指纹的特征是由AFIS自动提取的，而潜在指纹的特征是人工标记的。</p>
<p>&emsp;&emsp;如何自动提取潜指纹特征，特别是质量较差的潜指纹特征，是潜指纹特征识别中一个具有挑战性的问题。鉴于自动特征提取的难度，目前的做法是对潜在指纹的各种特征(如感兴趣区域(ROI)、奇异点和细节)进行手工标记。然而，潜指纹检测中的人为因素问题引起了对重复性和可靠性的关注。例如，一个特定的特征类型(例如，细节点)的标记，由不同的潜指纹检测员，甚至是同一个检测员在不同的时间，可能会给出不同的结果。NIST的一项研究表明，潜指纹匹配器的准确性受潜指纹检查标记的精度影响很大，特别是当潜指纹图像本身不能用于匹配时。影响人工标记性能的因素之一是，因为繁重的案件工作，潜指纹检测员经常在极端的时间压力下工作。研究表明，在指纹比对时间有限的情况下，潜指纹检测员更有可能在潜指纹和它的配对滚动指纹之间做出不确定的匹配决定。基于潜指纹匹配引起的身份错误中，最臭名昭著的案件之一是布兰登·梅菲尔德案件。无罪项目也报告了其他错误识别的案例。FBI下一代识别(NGI)的发展重点之一是支持lights-out功能的潜指纹识别(lights-out识别指的是一种自动识别系统，在这种系统中，查询指纹图像作为输入，输出由一个简短的候选列表组成)。这种lights-out功能的一个重要组成部分是开发一个全自动的潜指纹特征提取模块。为了(i)增加潜指纹匹配系统的吞吐量，(ii)提高潜指纹特征提取的可重复性，(iii)增加潜指纹提取的特征与AFIS(自动指纹识别系统)中参考指纹提取的特征之间的兼容性，这是非常可取的。</p>
<p>&emsp;&emsp;一个AFIS，无论是用于滚动/平面指印匹配还是潜指纹匹配，通常包含许多模块，包括感兴趣区域(ROI)分割(将指纹从背景中分离出来)、增强、特征提取和匹配。分割，特别是潜指纹的分割，是至关重要的，可以避免提取特征(如，细节点)在嘈杂的背景中的影响。增强脊线和谷线结构，去除前景区域的噪声是提取准确特征的关键。基于Gabor滤波的指纹增强能自适应地提高脊谷结构的清晰度；滤波器是根据局部脊线的方向和频率进行调整的。因此，对于潜指纹增强，获得良好的脊线方向和频率场估计是至关重要的。</p>
<p>&emsp;&emsp;此处省略1万字….(太长了，想直接看主要内容)</p>
<p>&emsp;&emsp;图3显示了一个潜在指纹示例，在该示例中，本文提出的分割和增强提高了COTS潜指纹匹配器的潜指纹识别性能(检索等级)。本文的主要贡献如下：</p>
<ol>
<li>提出了一种基于脊线结构字典的潜指纹特征分割和增强算法。这个字典从高质量的指纹块中学习而来。</li>
<li>一个指纹块的脊线质量定义为，该块与其从学习到的脊线结构字典中重构的块，的结构相似度。通过对图像的重构，可以估计出图像的方向和频率场。</li>
<li>为了兼顾鲁棒性和准确性，提出了一种基于64×64和32×32两种分辨率字典的从粗到精的策略。</li>
<li>所提出的分割和增强算法优于已发布的算法，并能显著提高最先进的商用潜指纹匹配器在两个潜指纹数据库(NIST SD27和WVU DB)上的性能。</li>
</ol>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_3.png" alt=""></p>
<p>本文的其余部分组织如下：第二节给出了所提算法的细节。实验结果报告在第3节。最后在第四部分给出了结论和未来的研究方向。</p>
<h1 id="提出的算法"><a href="#提出的算法" class="headerlink" title="提出的算法"></a>提出的算法</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_4.png" alt=""></p>
<p>&emsp;&emsp;本算法包括离线字典学习阶段和在线词典分割和增强阶段(图4)。在离线阶段，学习两种字典：</p>
<ol>
<li>一个块大小为64×64像素的粗级字典。</li>
<li>16个块大小为32×32像素的细级字典。</li>
</ol>
<p>这16个细的字典对应16个不同的脊线方向。采用64×64块大小的字典对脊线质量图、方向场和频率场进行粗略估计，采用16个不同方向的32×32块大小的字典对脊线质量图进行精细估计，并计算方向场和频率场。之所以在细级字典中选择的块大小为32×32像素，是因为32×32的块大概包含了500ppi指纹的两个脊线和谷线，这对结构噪声具有较强的鲁棒性。粗级字典(64×64像素)中的块大小是细级字典的两倍。<br>&emsp;&emsp;给定字典，在线潜指纹分割和增强包括以下步骤：</p>
<ol>
<li>潜指纹分解：通过局部总变量将输入的潜指纹分解为卡通图像(原文中用的是“cartoon”这个单词，确实是“卡通”的意思，我自己也？？？？)和纹理图像；卡通图像被丢弃了。</li>
<li>质量图、方向和频率场的粗略估计：将纹理图像分割成大小为64×64像素的重叠块($P_L^c$)。每个块有64×48或48×64个重叠像素与它的四个相邻块相连。对每个块$p \in P_L^c$，通过正交匹配追踪[34]得到其稀疏表示和粗级字典重构的块$\hat{p}$。$p$和$\hat{p}$之间的结构相似性被定义为块的粗质量。由于重构的块$\hat{p}$一般具有清晰的脊线模式，所以可以用重构的块$\hat{p}$中的特征来代替$p$中的脊线方向和频率。在块重叠区域，通过覆盖块来获得粗质量、粗方向和频率场。</li>
<li>质量图、方位和频率场的精确估计：纹理图像被分割成大小为32×32像素的重叠块($P_L^f$)。每个块有32×16或16×32个重叠像素与它的四个相邻块相连。对每个块$p \in P_L^f$，首先利用粗脊线方向值索引相应的细级字典。脊线质量图、方位和频率场的精确估计的计算方式和步骤2中的粗略估计相同。</li>
<li>分割与增强：将粗质量图和细质量图相结合进行潜指纹分割。利用步骤2和3中获得的方向和频率场，对纹理图像的前景部分进行Gabor滤波，进行潜指纹增强。</li>
</ol>
<h2 id="字典学习"><a href="#字典学习" class="headerlink" title="字典学习"></a>字典学习</h2><p>&emsp;&emsp;Feng等人最先提出使用字典进行指纹方向场估计。但是，他们的字典是基于方向块的，忽略了脊线结构信息。这是他们在[10]中的方法在分割和频率场估计方面不太成功的主要原因。在本节中，我们提出了脊线结构字典学习。</p>
<h3 id="训练集的选择"><a href="#训练集的选择" class="headerlink" title="训练集的选择"></a>训练集的选择</h3><p>&emsp;&emsp;为了构建可靠、鲁棒的指纹字典，从NIST SD4的滚动图像中选取了大量高质量的指纹块。选择的图像块如下所示：</p>
<ol>
<li>高质量指纹的选择：使用NIST指纹图像质量(NFIQ，猜测是是个质量评估工具)选择NIST SD4中高质量(即NFIQ &lt; 3)的500个指纹。</li>
<li>高质量块的选择：使用MINDTCT(NIST指纹图像软件(NFIS))来估计1中选择的指纹的方向场和每个块的脊线质量图。脊线质量图为每个块提供了5个质量等级中的一个(4是最高质量，0是最低质量)。对于粗级字典，采用步长为8像素滑动窗口的方法，在指纹图像上选择一组大小为64×64像素的图像块$P^c$；如果图像块的平均质量值大于预定义的阈值$T$($T$设为3.75)，则该块被纳入训练集。对于方向特定的细级字典，根据脊线方向构造16组指纹块$P^F_i,i = 1,···,16$。对于$P^f_i$，在指纹图像上滑动一个32×32的窗口；当一个块满足以下两个条件时：i)块的平均质量值大于$T$, ii)块的平均脊线方向在$[ (i - 1) \times \frac{\pi}{6}, i \times \frac{\pi}{6} )$范围内，则选择该块。</li>
<li>向量归一化：对训练集中的每个块$p$通过公式(1)进行归一化，然后通过行串接将其转换为向量。<br>$$ \tilde{p} = (p - \mu_p) / \sigma_p \tag{1}<br>$$ 其中$\mu_p$是块$p$的平均强度，$\sigma_p$是块$p$的标准差。</li>
</ol>
<p>&emsp;&emsp;用$P^c = \left\{ p^c_j \right\}^{N^c}_{j=1}$表示粗级字典的训练集，其中$N^c$表示在$P^c$中训练块的数量，用$P^f_i = \left\{ p^f_{i,j} \right\}^{N^f_i}_{j=1} $，$i = 1,· · ·,16$，表示16个细级字典的训练集，其中$N^f_i$表示第$i$个特定脊线方向字典的训练块数量。为了平衡效率和准确性，我们从$P^c$中随机选取80,000个块，从每个$P^f_i$中随机选取10,000个块进行字典学习。</p>
<h3 id="字典学习-1"><a href="#字典学习-1" class="headerlink" title="字典学习"></a>字典学习</h3><p>&emsp;&emsp;不失一般性，对于一个训练集$P = \left\{ p_j \right\}^{N^c}_{j=1}$，字典学习的目标是构建一个大小为$N_P \times N_D$字典$D$，$D$需要提供$P$中每个块的最佳稀疏表示, $N_P$是$P$中块的维度，$N_D$是字典里$D$中元素的数量。一个典型的字典学习目标函数是：<br>$$ \min_{D, \Gamma}\| P - D\Gamma \|_F^2 \ \ s.t.\forall j, \ \ \|\gamma_j\|_0 \leq T_0, \tag{2}<br>$$ 其中$\gamma_j$是大小为$N_D \times N$的矩阵$\Gamma$的第$j$列，$\|\cdot\|_0$是计算表示中非零项个数的$l^0$范数，$T_0$是预定的非零项个数，$\|\cdot\|_F$是Frobenius范数。字典学习的有效算法之一是K-SVD，它通过以下两个阶段的迭代来最小化公式(2)中的目标函数。</p>
<ul>
<li>稀疏编码阶段：在固定字典$D$下，通过求解以下优化问题，得到$P$中每个块$p_j$的系数向量$\gamma_j$的表示：<br>$$<br>\min_{\gamma_j} \| p_j - D_{\gamma_j} \|_2^2 \ s.t. \ \| \gamma_j \|_0 \leq T_0, j = 1,2,…,N, \tag{3}<br>$$</li>
<li>字典更新阶段：这一阶段通过奇异值分解(SVD)每次更新字典$D$的一列，同时固定$D$的所有其他列，从而减小公式(2)中的目标函数。</li>
</ul>
<p>使用离散余弦变换(DCT)基础构造初始字典D。每个字典元素学习后都通过公式(1)进行归一化。</p>
<p>&emsp;&emsp;以$P^c$和$P^f_i, i = 1，···，16$为训练集，共构造了17个不同的字典(粗级字典$D^c$和16个细级字典$D^f_i, i = 1，···，16$)。将粗级字典中的元素个数$N^c_D$设置为1024，将每个细级字典中的元素个数$N^f_D$设置为64。图5显示了粗级字典$D^c$中的字典元素子集，图6显示了16个细级字典中的字典元素子集。</p>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_5.png" alt=""></p>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_6.png" alt=""></p>
<h2 id="潜指纹图像分解"><a href="#潜指纹图像分解" class="headerlink" title="潜指纹图像分解"></a>潜指纹图像分解</h2><p>&emsp;&emsp;一个潜指纹图像，$f$，可以用两部分的和来表示：$f = u + v$，其中$u$表示$f$的卡通(分段光滑)部分，$v$表示振荡部分或纹理部分。Buades等人利用低通滤波不会使卡通图像的总变化量减小的特点，提出了一种基于局部总变化量(LTV)的快速非线性分解方法。在一个像素$x$处的局部总变化量定义为：<br>$$<br>LTV_{\sigma}(f)(x) = L_{\sigma} * |\nabla f|(x), \tag{4}<br>$$ 其中，$L_{\sigma}$是一个$\sigma$大小的低通滤波器，其傅里叶变换由$\hat{L}_{\sigma}(\xi) = 1/(1 + (2 \pi \sigma \xi)^4)$获得。用低通滤波器对图像进行滤波前后，$LTV$的相对减小率$\lambda_\sigma(x)$可以测量图像的局部振荡行为，$\lambda_\sigma(x)$由以下公式计算得到：<br>$$<br>\lambda_\sigma(x) = \frac{LTV_\sigma(f)(x) - LTV_\sigma(L_\sigma * f)(x)}{LTV_\sigma(f)(x)}. \tag{5}<br>$$ 当$\lambda_\sigma(x)$接近1时，说明低通滤波后的$LTV$降低了很多，像素$x$属于纹理部分。另一方面，当$\lambda_\sigma(x)$接近0时，低通滤波后的$LTV$相对降低很少，像素$x$属于分段平滑的卡通部分。因此，卡通部分$u$和纹理部分$v$可由$f$和$L_\sigma * f$根据$\lambda_\sigma(x)$加权和提取：<br>$$ u(x) = w(\lambda_\sigma(x))((L_\sigma * f)(x) - f(x)) + f(x), \tag{6} $$</p>
<p>$$ v(x) = f(x) - u(x), \tag{7} $$</p>
<p>其中$w(y)$是一个分段线性递增函数，定义为：<br>$$<br>w(y) = \begin{cases}<br>0                     &amp; y &lt; a_1, \\<br>(y - a_1)/(a_2 - a_1) &amp; a_1 &lt; y &lt; a_2, \\<br>1                     &amp; y &gt; a_2.<br>\end{cases}<br>\tag{8}<br>$$ 如果$w(\lambda_\sigma(x)) = 0$(像素$x$属于卡通部分)，$u(x)$等于$f(x)$，$v(x)$等于0。如果$w(\lambda_\sigma(x)) = 1$(像素$x$属于纹理部分)，$u(x)$等于低通滤波图像$L_\sigma * f(x)$中的像素值，$v(x)$等于原图像$f(x)$与低通滤波图像$L_\sigma * f(x)$的差值。</p>
<p>&emsp;&emsp;图9(b)显示了图9(a)中三幅不同的潜图像的纹理部分；在保持摩擦脊模式的同时，大部分的结构噪声被成功地去除。</p>
<h2 id="脊线质量、方位和频率的粗略估计"><a href="#脊线质量、方位和频率的粗略估计" class="headerlink" title="脊线质量、方位和频率的粗略估计"></a>脊线质量、方位和频率的粗略估计</h2><h3 id="稀疏编码"><a href="#稀疏编码" class="headerlink" title="稀疏编码"></a>稀疏编码</h3><p>&emsp;&emsp;对于每个块$p \in P^c_L$用公式(1)进行了归一化，并且通过行连接的方式转化为了向量。$p$的稀疏表示可以通过正交匹配追踪求解下面的优化问题得到：<br>$$<br>\min_\alpha \| p - D^c \alpha \|_2^2 \ \ s.t. \ \| \alpha \|_0 \leq T_1, \tag{9}<br>$$ 其中$\alpha$为稀疏系数向量，其中最多$T_1$项不为零，$D^c$为粗级字典。根据$\alpha$中的非零项，选择字典$D^c$中元素的子集$D^c_s$。设$\alpha’$为$D^c_s$对应的非零系数。然后将$p$投影到$D^c_s$的元素张成的空间上。近似计算为：<br>$$<br>\hat{p} = D^c_s \alpha’, \tag{10}<br>$$  其中，$\alpha’$由以下公式获得：<br>$$<br>\alpha’ = (D^{cT}_s D^c_s)^{-1} D^{cT}_s p. \tag{11}<br>$$ 残差向量可以计算为：<br>$$<br>r(p) = p - \hat{p} = p - D^c_s \alpha’. \tag{12}<br>$$</p>
<h3 id="块质量的定义"><a href="#块质量的定义" class="headerlink" title="块质量的定义"></a>块质量的定义</h3><p>&emsp;&emsp;一般来说，当$p$是指纹块时，重构误差$\|r(p)\|_2$较小。但是，这种按像素计算的误差衡量忽略了指纹图像的空间属性。为此，我们使用图像$I_1$和$I_2$之间的结构相似指数(SSIM)来计算重构误差，其定义为：<br>$$<br>SSIM(I_1, I_2) = \frac{(2\mu_1\mu_2 + C_l)(2\sigma_{12} + C_c)}{(\mu_1^2 + \mu_2^2 + C_l)(\sigma_1^2 + \sigma_1^2 + C_c)}, \tag{13}<br>$$ 其中$\mu_1$和$\sigma_1$是图像$I_1$的平均强度和标准差，$\mu_2$和$\sigma_2$是图像$I_2$的平均强度和标准差，$\sigma_{12}$为图像$I_1$和$I_2$之间的协方差，$C_l$和$C_c$是降低计算不稳定性的参数。</p>
<p>&emsp;&emsp;图7比较了$T_1$从1变到4时，两个指纹块(顶部和中间的两行)和一个非指纹块(底部的一行)的重构结果和SSIM指数。我们可以看到，高质量的指纹块在块$p$与其重构块$\hat{p}$之间的SSIM值很大，而非指纹块的SSIM值很小。块$p$的质量$Q_p$定义为：<br>$$<br>Q_p = SSIM(p, \hat{p}). \tag{14}<br>$$</p>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_7.png" alt=""></p>
<h3 id="脊线质量图，方向场和频率场估计"><a href="#脊线质量图，方向场和频率场估计" class="headerlink" title="脊线质量图，方向场和频率场估计"></a>脊线质量图，方向场和频率场估计</h3><p>&emsp;&emsp;重构后的块$p$被分割成不重叠的16×16的块，就像[12]和[10]中使用的那样。对于每个块，根据[12]得到其方向和频率，然后得到重构出的块方向场$\theta_{\hat{p}}$(如图8)和频率场$f_{\hat{p}}$。利用重构后的块$\hat{p}$的方向场$\theta_{\hat{p}}$和频率场$f_{\hat{p}}$估计了潜指纹图像中块$p$的方向场$\theta_p$和频率场$f_p$。对于一个被多个块覆盖的区域，其质量、方向和频率定义如下。将潜指纹图像分为不重叠的16×16块。对于潜指纹中的每个区域$b$，设$\{q_i,\theta_i,f_i\}$为重叠区域$b$中第$i$个块的脊线质量、方向和频率。对脊线质量$Q^c_b$、方向$\theta^c_b$和频率$f^c_b$的粗略估计为：<br>$$ Q^c_b = \frac{1}{n_b} \sum^{n_b}_{i=1}{q_i}, \tag{15} $$</p>
<p>$$ \theta^c_b = \frac{1}{2} \tan^-1 \left( \sum^{n_b}_{i=1}{q_i\sin{2\theta_i}}, \sum^{n_b}_{i=1}{q_i\cos{2\theta_i}} \right), \tag{16} $$</p>
<p>$$ f^c_b = \frac{1}{\sum^{n_s}_{i = 1}{q_i}} \sum^{n_s}_{i = 1}{q_i f_i}, \tag{17} $$</p>
<p>其中$n_b$是重叠区域$b$中块的数量。</p>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_8.png" alt=""></p>
<h3 id="稀疏程度控制"><a href="#稀疏程度控制" class="headerlink" title="稀疏程度控制"></a>稀疏程度控制</h3><p>&emsp;&emsp;公式(9)中的参数$T_1$用来控制稀疏编码的稀疏程度。从图7和图8可以看出，虽然较大的$T_1$值可以更好地近似输入块，但它引入了不需要的噪声。特别地，单个字典元素就足以恢复第一级特性(方向和频率)。当$T_1 = 1$时，系数向量$\alpha’$变为标量，$\alpha’$的计算可以简化为：<br>$$ \alpha’ = \frac{1}{N_p - 1} D^{cT}_s p, \tag{18} $$</p>
<p>其中$N_p$是块$p$中的像素个数，因为不需要进行矩阵求逆(见公式(11))，公式(18)给出了一个有效的解。由于块$p$归一化后均值为0，标准差为1，因此公式(13)中的SSIM指标计算可以简化为：<br>$$ SSIM(p, \hat{p}) = \frac{2\alpha’^2 + C_c}{1 + \alpha’^2 + C_c}. \tag{19} $$</p>
<p>&emsp;&emsp;需要注意的是，当$T_1 = 1$时，重构的块是从字$D^c$中选择的一个元素。这样，可以在离线阶段预先计算字典元素的方向和频率场，大大提高了方向和频率场的估计速度。由于这些原因，$T_1$被设为1。图9(c)为$T_1 = 1$条件下的粗质量图的一些示例。</p>
<p><img src="/images/paper/Segmentation_and_Enhancement_of_Latent_Fingerprints/fig_9.png" alt=""></p>
<h2 id="脊线质量，方向和频率的精确估计"><a href="#脊线质量，方向和频率的精确估计" class="headerlink" title="脊线质量，方向和频率的精确估计"></a>脊线质量，方向和频率的精确估计</h2><p>&emsp;&emsp;粗级字典对局部噪声具有鲁棒性，但不能提取详细的脊线信息。小块字典使我们能够计算精确的质量图，计算精确的方向场和频率场：</p>
<ol>
<li>$P^f_L$中的所有块都通过公式(1)进行归一化，均值为0，标准差为1。</li>
<li>对于每个块$p \in P^f_L$，通过平均被块$p$覆盖区域的粗糙方向，得到一个优化的方向$\theta$，然后为块$p$选择对应方向的特定字典$D^f_k$，其中$k =     \left\lceil \frac{16 \times \theta}{\pi} \right\rceil$，$\left\lceil \cdot \right\rceil$为向上取整运算。</li>
<li>重构的块$p$是通过字典$D^f_k$求解公式(9)中的优化问题得到的。</li>
<li>块$p$的质量由$p$与$\hat{p}$的结构相似性决定(公式(19))。</li>
<li>块$p$的块方向和频率场由$\hat{p}$根据[12]的方法计算。</li>
<li>对于潜指纹中每个16×16的区域$b$，利用公式(15)、(16)及(17)，从重叠块中获得了精确的质量$Q^f_b$、方位$\theta^f_b$和频率$f^f_b$。</li>
</ol>
<h2 id="分割和增强"><a href="#分割和增强" class="headerlink" title="分割和增强"></a>分割和增强</h2><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>&emsp;&emsp;最终得到的质量图$Q$是粗级质量和细级质量的平均值：<br>$$ Q = \frac{1}{2}(Q^c + Q^f). \tag{20} $$</p>
<p>&emsp;&emsp;然后将质量图$Q$归一化到[0,1]范围内。采用全局阈值$T_Q$(采用Otsu的方法[42]归一化$Q$值)对归一化质量图进行二值化。质量低于$T_Q$的块作为背景(即0)，否则作为前景(即1)。为了得到最终的分割结果，我们对前景中的小块进行形态学操作(膨胀和开操作)，从而填充前景中的孔洞。最后，计算前景块集的凸包，得到最终的分割结果。图9(e)为NIST SD27潜指纹图像分割结果的一些示例。</p>
<h3 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h3><p>&emsp;&emsp;在前景区域，通过Gabor滤波[12]对分解后的潜指纹的纹理图像进行增强。基于细级方向场($\theta^f$)和粗级频率场和细级频率场的平均频率($\frac{f^f + f^c}{2}$)，对滤波器的方向和频率参数进行了调整；Gabor滤波器中的高斯envelope的标准差设为4。</p>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>&emsp;&emsp;我们使用两个潜指纹数据库进行性能评估：NIST SD27[43]和西弗吉尼亚大学潜指纹数据库(WVU DB)[44]。NIST SD27包含258个潜在指纹和他们配对的滚动指纹。WVU DB包含449个潜在指纹及其配对的滚动指纹和额外的4290个滚动指纹（<a href="https://biic.wvu.edu/data-sets/3-d-face-databset" target="_blank" rel="noopener">3D人脸和指纹数据集</a>）。该算法在MATLAB和C/C++环境下实现，运行在双核2.66GHz，4GB RAM和Windows 7操作系统上。对于NIST SD27和WVU DB来说，每个潜指纹的分割和增强的平均计算时间分别为2.6秒和1.6秒。<br>&emsp;&emsp;对潜指纹图像进行分割和增强的最终目的是提高潜指纹的匹配性能。使用三个商用off-the-shelf(COTS)匹配器(简称COTS1、COTS2和COTS3)对匹配性能进行评估；COTS1和COTS2是十指匹配器，COTS3是一个潜指纹匹配器。VeriFinger SDK 6.3是其中一个COST十指匹配器，已被广泛地用于做基准测试。我们分别测试了使用十指匹配器和潜指纹匹配器的匹配性能。十指匹配器用来比较所提出的算法与其他文献报道的分割和增强算法(显然，这些研究人员无法获得潜指纹匹配器)。一个最先进的潜指纹匹配器用来确定所提出的算法是否能够提高它的匹配性能。</p>
<h2 id="Tenprint匹配器的匹配性能"><a href="#Tenprint匹配器的匹配性能" class="headerlink" title="Tenprint匹配器的匹配性能"></a>Tenprint匹配器的匹配性能</h2><p>&emsp;&emsp;在本节中，我们测试了使用所提出的分割和增强算法，是否能够提高两个COTS十指匹配器的性能。</p>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title>DenseBox: Unifying Landmark Localization with End to End Object Detection</title>
    <url>/papers/dense_box/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/densebox.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="Abstract（摘要）"><a href="#Abstract（摘要）" class="headerlink" title="Abstract（摘要）"></a>Abstract（摘要）</h1><p>&emsp;&emsp;<strong>DenseBox</strong>：一个用于做目标检测，统一的端到端的FCN框架，通过检测目标在图像中的所有可能的位置和尺度，直接预测目标的边界框和类别的置信度。</p>
<h1 id="Introduction（介绍）"><a href="#Introduction（介绍）" class="headerlink" title="Introduction（介绍）"></a>Introduction（介绍）</h1><p>已有的目标检测方法：</p>
<ul>
<li><strong>传统方法</strong>：滑动窗口 + 手工提取的特征  —&gt;  目标的位置和尺度</li>
<li><strong>FCN</strong>：滑动窗口 + 卷积神经网络提取的特征  —&gt;  目标的位置和尺度</li>
<li><strong>R-CNN</strong>：比一般基于FCN的目标检测方法准确率更高的方法，<br>  包括两个阶段:<ul>
<li>第一个阶段：使用区域提出的方法，生成图像中所有可能的候选边界框。</li>
<li>第二个阶段：用一个CNN分类器对每个候选区域分类。</ul>R-CNN缺点：<ul></li>
<li>难以检测到小的目标，比如人脸和远处的车辆。因为取块以后的区域分辨率低，并且没有利用到全局的信息。</li>
<li>两个阶段不能联合优化，难以进行端到端的训练。</li>
</ul>
</li>
</ul>
<p>作者的研究方向：只用一个FCN，在目标检测上能做到什么程度。所以就设计了DenseBox。<br><strong>DenseBox</strong>：类似于许多现有的滑动窗口式FCN检测框架，但是，是专门为检测小尺度和遮挡严重下的物体设计的。<br>训练时加入的两个优化：</p>
<ol>
<li>应用了严格的负样本挖掘。</li>
<li>使用多任务学习，将landmark定位集成到系统中。</li>
</ol>
<p>作者两个方面的贡献：</p>
<ol>
<li>证明了，一个单一的FCN，如果精心设计和优化，可以非常准确并且高效地检测多个不同的目标。</li>
<li>证明了，在多任务学习中结合landmark定位，DenseBox可以进一步提高目标检测的准确性。</li>
</ol>
<p>实验数据库：MALF人脸检测和KITTI汽车检测。</p>
<h1 id="Related-Work（相关工作）"><a href="#Related-Work（相关工作）" class="headerlink" title="Related Work（相关工作）"></a>Related Work（相关工作）</h1><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><ol>
<li>手工提取特征（HOG，SIFT，Fisher Vector）</li>
<li>建立目标模型（PSM，DPM），推测是选出目标候选区域</li>
<li>利用分类器分类（SVM）</li>
</ol>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><ol>
<li>1994 Vaillant等人提出用卷积神经网络来做人脸检测。</li>
<li>1996～1998 Rowley等人提出用神经网络来检测图像金字塔的正脸。</li>
</ol>
<p>具有借鉴意义，与DenseBox的设计有相似的地方。</p>
<h2 id="深度卷积神经网络"><a href="#深度卷积神经网络" class="headerlink" title="深度卷积神经网络"></a>深度卷积神经网络</h2><ol>
<li><strong>OverFeat</strong>：</li>
<li><strong>MultiBox</strong>：用一个网络来生成多个候选区域，然后用R-CNN对候选区域进行目标检测。</li>
<li><strong>YOLO</strong>：</li>
</ol>
<p>&emsp;&emsp;大部分最新的方法都依赖于R-CNN，但是将检测分成两个阶段会造成模型对小尺寸的人脸和复杂外观变化的人脸遗忘，导致其在人脸检测等检测任务中的性能较差。<br>&emsp;&emsp;YOLO和Fast R-CNN将候选边界框和分类结合到一个或两个阶段中。</p>
<h1 id="DenseBox-for-Detection（DenseBox用于检测）"><a href="#DenseBox-for-Detection（DenseBox用于检测）" class="headerlink" title="DenseBox for Detection（DenseBox用于检测）"></a>DenseBox for Detection（DenseBox用于检测）</h1><p>&emsp;&emsp;用单个卷积神经网络同时输出多个预测边界框和分类置信度。<br>&emsp;&emsp;输入：大小为$m \times n$的图像。<br>&emsp;&emsp;输出：大小为$\frac{m}{4} \times \frac{n}{4}$的5通道特征映射，1个通道用来预测分类置信度，其他4个通道用来预测边界框。</p>
<p>目标边界框左上角坐标：$p_t = (x_t, y_t)$<br>目标边界框右下角坐标：$p_b = (x_b, y_b)$</p>
<p>输出的特征映射中坐标为$(x_i, y_i)$的像素i输出为<br>$$<br>\hat{t_i} = { \hat{s}, \hat{dx^t}, \hat{dy^t}, \hat{dx^b}, \hat{dy^b} }_i<br>$$</p>
<ul>
<li>$\hat{s}$：像素i是一个目标的置信度。</li>
<li>$\hat{dx^t}, \hat{dy^t}, \hat{dx^b}, \hat{dy^b}$：像素i离上下左右四个边界框的距离。<br>$$<br>\hat{dx^t} = x_i - x_t \\<br>\hat{dy^t} = y_i - y_t \\<br>\hat{dx^b} = x_i - x_b \\<br>\hat{dy^b} = y_i - y_b \\<br>$$</li>
</ul>
<p>最后将输出map的每个像素转化为一个边界框，对分数超过阈值的边界框进行非最大抑制。</p>
<h2 id="Ground-Truth-Generation（训练标签）"><a href="#Ground-Truth-Generation（训练标签）" class="headerlink" title="Ground Truth Generation（训练标签）"></a>Ground Truth Generation（训练标签）</h2><p>&emsp;&emsp;为了减少训练时间，作者将训练的图片裁剪缩放成大小为240×240的图片，每张图片中心有一个大约50个像素高的人脸。<br>&emsp;&emsp;标签是大小为60×60的边界框对应的5通道map，被下采样了4倍。<br><img src="/images/paper/dense_box/fig_2.png" alt=""></p>
<p>&emsp;&emsp;第1个通道用于分类，将人脸正中心半径为$r_c$的圆形区域作为分类的正样本，$r_c$的大小根据边界框的大小来调整，比例因子是0.3，在圆形区域内的标签值设为1，其他区域作为负样本，值设为0。<br>&emsp;&emsp;其他4个通道用于标记边界框大小，表示像素离上下左右四个边界框的距离。</p>
<p>&emsp;&emsp;如果一张图像中包含多个人脸，只将正中心区域的作为正样本，其他作为负样本。</p>
<h2 id="Model-Design（模型设计）"><a href="#Model-Design（模型设计）" class="headerlink" title="Model Design（模型设计）"></a>Model Design（模型设计）</h2><p><img src="/images/paper/dense_box/fig_3.png" alt=""><br>&emsp;&emsp;主干部分来源于VGG19，包含12个卷积层。<br>&emsp;&emsp;输出部分包括4个1×1的卷积层，作用相当于全连接层，前两个用于预测分类分数，后两个用于预测边界框。</p>
<p><strong>多层次特征融合</strong>：conv3_4输出的特征映射，每个像素的感受野是48×48，有利于检测局部细节，conv4_4的感受野是118×118，能利用到全局的特征，将这两种特征结合有利于最终的检测。</p>
<h2 id="Multi-Task-Training（多任务训练）"><a href="#Multi-Task-Training（多任务训练）" class="headerlink" title="Multi-Task Training（多任务训练）"></a>Multi-Task Training（多任务训练）</h2><p>&emsp;&emsp;网络包含两个训练任务，一个是训练分类分数，一个是训练边界框。<br>&emsp;&emsp;训练使用的损失函数都是$L2$损失函数，不用其他的函数是因为简单的$L2$损失函数的训练效果还不错。<br>$$<br>L_{cls}(\hat{y}, y^*) = ||\hat{y} - y^*||^2 \\<br>L_{loc}(\hat{d}, d^*) = \sum_{i\in{tx,ty,bx,by}}||\hat{d_i} - d_i^*||^2<br>$$</p>
<h3 id="Balance-Sampling（平衡样本）"><a href="#Balance-Sampling（平衡样本）" class="headerlink" title="Balance Sampling（平衡样本）"></a>Balance Sampling（平衡样本）</h3><p>&emsp;&emsp;负样本在所有样本中占主导地位，如果简单地在小批量中使用所有负样本，将会使预测偏向于负样本。</p>
<p>&emsp;&emsp;<strong>忽略灰度区域</strong>：将正负样本交界处的样本忽略，不参加训练。如果一个样本2个像素半径范围内有正样本，则看做是灰度区域，这部分区域用$f_{ign} = 1$表示。</p>
<p>&emsp;&emsp;<strong>困难样本挖掘</strong>：困难样本是训练效果差的样本，训练时增加困难样本被选中的概率。训练时将所有样本的损失值按从大到小排序，将前1%的样本作为困难样本，用于训练的样本一半从困难样本选择，另一半从其他样本中随机选择，被选中样本用$f_{sel} = 1$表示。</p>
<p>&emsp;&emsp;<strong>损失掩码</strong>：<br><img src="/images/paper/dense_box/eq_3.png" alt=""><br><img src="/images/paper/dense_box/eq_4.png" alt=""></p>
<p>$M(\hat{t_i})$表示负样本的损失掩码。<br>$[y^*&gt;0]$表示边界框的损失值只考虑负样本。<br>$\lambda_{loc}$是两个损失值的平衡因子，在这里设为3。</p>
<p>&emsp;&emsp;<strong>其他细节</strong>：</p>
<ul>
<li>正块：在特定的尺度下选取的块，中心部分包含一个目标。</li>
<li>随机块：在随机尺度下随机选取的块。</li>
</ul>
<p>训练时，正块和随机块选取的比例是1:1。然后加入了镜像、颜色抖动、线性变换增强方法。<br>训练的参数：<br>优化策略：小批量SGD<br>batch size：10<br>学习率：初始0.001，每迭代10万次乘0.1。<br>动量：0.9<br>权重衰减：0.0005</p>
<h3 id="Refine-with-Landmark-Localization（用landmark定位优化）"><a href="#Refine-with-Landmark-Localization（用landmark定位优化）" class="headerlink" title="Refine with Landmark Localization（用landmark定位优化）"></a>Refine with Landmark Localization（用landmark定位优化）</h3><p><img src="/images/paper/dense_box/fig_4.png" alt=""></p>
<p>在DenseBox网络中加入landmark的回归，然后将其与用于分类的conv5_2结合，可以增强模型的检测性能。<br>相当于给分类增加一个约束，可以让分类的部分学的更好。<br><img src="/images/paper/dense_box/eq_5.png" alt=""></p>
<p>$\lambda_{det}$和$\lambda_{lm}$是平衡因子，在这里设置成1和0.5。</p>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Robust Minutiae Extractor:Integrating Deep Networks and Fingerprint Domain Knowledge</title>
    <url>/papers/minutiae_net/</url>
    <content><![CDATA[<p><a href="https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/MinutiaeNet.pdf" target="_blank" rel="noopener">论文原文下载链接</a></p>
<h1 id="Abstract（摘要）"><a href="#Abstract（摘要）" class="headerlink" title="Abstract（摘要）"></a>Abstract（摘要）</h1><p>&emsp;&emsp;提出了一个基于深度神经网络的全自动指纹细节点提取器。</p>
<ul>
<li><strong>CoarseNet</strong>: 粗糙的网络，基于卷积神经网络和指纹领域知识，估计细节点位置和方向。</li>
<li><strong>FineNet</strong>: 精细的网络，基于细节点的分数热力图对候选细节点位置进一步优化。</li>
</ul>
<p>&emsp;&emsp;由于缺乏基于细节点标注的指纹数据集，本文提出的细节点检测方法将有助于训练基于网络的指纹匹配算法。</p>
<h1 id="Introduction（介绍）"><a href="#Introduction（介绍）" class="headerlink" title="Introduction（介绍）"></a>Introduction（介绍）</h1><p>&emsp;&emsp;<strong>传统方法</strong>：主要利用指纹领域知识和手工特征提取细节点。在质量好的指纹图像上效果好，但是在质量差的指纹上效果不好，尤其是现场指纹。</p>
<p>&emsp;&emsp;<strong>深度学习方法</strong>：</p>
<ul>
<li>利用滑动窗口等方式，生成细节点的候选块，然后用分类器判断是不是细节点。缺点是比较耗时。</li>
<li>FingerNet：将传统的细节点提取方法(包括方向场、分割、增强和细节点提取)映射到一个固定权值的网络。结合了指纹的领域知识和深度学习，比较有前景，不过使用的网络结构比较普通，非极大值抑制用的是硬阈值。</li>
</ul>
<p><strong>作者的贡献</strong>：</p>
<ol>
<li>提出了一种基于网络的细节点自动提取器，利用领域知识提供可靠的细节点位置和方向，不需要调硬阈值。</li>
<li>一个鲁棒的基于块的细节点分类器，显著提高了候选块精度和召回率。这可以作为一个鲁棒的，带有紧凑细节点特征的细节点提取器。</li>
<li>提出了一种非极大值抑制方法，用来获取候选块的精确位置。在FVC 2004和NIST SD27的实验评估表明，该方法在精度、召回率和F1分数等方面优于已发表的方法。</li>
</ol>
<h1 id="Proposed-framework（提出的框架）"><a href="#Proposed-framework（提出的框架）" class="headerlink" title="Proposed framework（提出的框架）"></a>Proposed framework（提出的框架）</h1><p>&emsp;&emsp;提出了一个新的框架，结合指纹领域知识的深度神经网络来提取细节点，包括两个模块。</p>
<ul>
<li><strong>CoarseNet</strong>: 基于残差学习的卷积神经网络，从输入指纹图像中生成包含细节的候选。以指纹图像为初始输入，以相应的增强图像、分割图、方向场作为次级输入，生成细节点分数图。通过与指纹方向场的比较，估计指纹的细节点方向。</li>
<li><strong>FineNet</strong>: 基于inception-resnet的细节点分类器，对CoarseNet输出的候选块进行分类。对每一个以候选细节点为中心的正方形区域进行处理，优化细节点分数图，回归细节点的方向。将分类结果作为最后得到的细节点。</li>
</ul>
<p><img src="/images/paper/minutiae_net/figure_2.png" alt="" title="图2 提出的自动细节点提取结构。CoarseNet以完整指纹图像作为输入，FineNet对CoarseNet输出的细节点块进行处理"></p>
<h2 id="CoarseNet-for-minutiae-extraction（提取细节点的粗网）"><a href="#CoarseNet-for-minutiae-extraction（提取细节点的粗网）" class="headerlink" title="CoarseNet for minutiae extraction（提取细节点的粗网）"></a>CoarseNet for minutiae extraction（提取细节点的粗网）</h2><p><img src="/images/paper/minutiae_net/figure_3.png" alt="" title="图3 CoarseNet的结构"><br>&emsp;&emsp;将深度神经网络和领域知识结合。先生成指纹的分割图、方向图和增强图这些附产物，再根据这些附产物生成细节点分数图。目的是让模型更加鲁棒。</p>
<h3 id="Segmentation-and-orientation-feature-sharing（分割和方向场特征共享）"><a href="#Segmentation-and-orientation-feature-sharing（分割和方向场特征共享）" class="headerlink" title="Segmentation and orientation feature sharing（分割和方向场特征共享）"></a>Segmentation and orientation feature sharing（分割和方向场特征共享）</h3><p>&emsp;&emsp;网络结构特点：</p>
<ul>
<li>使用更深的残差结构来提取多尺度特征。</li>
<li>使用ASPP网络来融合网络的多层次输出，可以得到输入图像中各层次对应区域的概率图。</li>
</ul>
<p>&emsp;&emsp;在CoarseNet中，指纹的分割和方向场估计共享卷积层。在进行方向场估计的时候，使用了Dictionary-based方法与CoarseNet的方向场预测融合，作为最后的方向场输出，融合权重比例1:3。</p>
<h3 id="Candidate-generation（候选生成）"><a href="#Candidate-generation（候选生成）" class="headerlink" title="Candidate generation（候选生成）"></a>Candidate generation（候选生成）</h3><p><img src="/images/paper/minutiae_net/figure_4.png" alt="" title="图4 候选块的处理映射。分数图的级别越低，它提供的细节就越多"><br>&emsp;&emsp;利用方向场和增强模块，将输入的原始图像增强，得到指纹的增强图，然后将增强图和分割图结合，作为细节点提取网络的输入。<br>&emsp;&emsp;细节点提取网络也用了残差结构和多层次结构。将第4层的分数图作为粗定位，将低层次的分数图作为精确定位。</p>
<h3 id="Non-maximum-suppression（非极大值抑制）"><a href="#Non-maximum-suppression（非极大值抑制）" class="headerlink" title="Non-maximum suppression（非极大值抑制）"></a>Non-maximum suppression（非极大值抑制）</h3><p>&emsp;&emsp;常用的方法：对候选列表按分数排序，计算每个点对两两之间的位置和方向的L2距离，然后迭代的方法，将每个候选和列表里的其他候选比较，保留位置和方向的L2距离超过阈值，且分数高的候选。<br>&emsp;&emsp;作者提出的方法：对候选列表按分数排序，保留分数高的点，去掉分数比原先已选择的候选低，且与已选择的候选重叠区域超过50%的点。</p>
<h3 id="Training-data-for-CoarseNet（粗网的训练数据）"><a href="#Training-data-for-CoarseNet（粗网的训练数据）" class="headerlink" title="Training data for CoarseNet（粗网的训练数据）"></a>Training data for CoarseNet（粗网的训练数据）</h3><p>&emsp;&emsp;训练分割和方向场模块时使用弱标签，细节点提取部分采用两个库的ground truth标签，使用了数据增强。</p>
<h2 id="FineNet（细网）"><a href="#FineNet（细网）" class="headerlink" title="FineNet（细网）"></a>FineNet（细网）</h2><p>&emsp;&emsp;虽然粗网是可靠的，但它仍然不能识别真实的细节点或识别伪细节点。所以需要使用FineNet，一个对生成的候选块进行分类的细节点分类器。FineNet将CoarseNet输出的候选细节点作为输入，判读对应的10×10中心区域是否是个有效的细节点。</p>
<h3 id="FineNet-architecture（细网结构）"><a href="#FineNet-architecture（细网结构）" class="headerlink" title="FineNet architecture（细网结构）"></a>FineNet architecture（细网结构）</h3><p><img src="/images/paper/minutiae_net/figure_5.png" alt="" title="图5 FineNet的架构。关于inception-resnet v1 块结构的详细信息，请参阅[20]"></p>
<p>&emsp;&emsp;FineNet的输入。提取了相同数量的细节和非细节块，大小为$t_1 \times t_1$，$t_1 = 45$。将提取的这些块，缩放成$t_2 \times t_2$的图像，这里$t_2 = 160$，之所以放大成160，是因为，图像太小无法训练复杂的网络结构，图像缩放太大会模糊一些微小的细节。<br>&emsp;&emsp;FineNet的训练数据。正样本是基于ground truth的细节点位置提取的块，负样本是随机采样的非细节点位置提取的块，负样本的中心区域(10×10)不包含部分或全部的细节点位置。使用了批量归一化、旋转、镜像、尺度变换和边界模糊等预处理方法。</p>
<h3 id="Losses-and-implementation-details（loss函数和实施细节）"><a href="#Losses-and-implementation-details（loss函数和实施细节）" class="headerlink" title="Losses and implementation details（loss函数和实施细节）"></a>Losses and implementation details（loss函数和实施细节）</h3><p>&emsp;&emsp;<strong>Intra-Inter分类损失</strong>（Intra-Inter class losses）：使用Center Loss[25]作为softmax loss的补充。softmax loss倾向于拉大不同类别特征的区别，而center loss倾向于将同一类别的特征拉的更近。具体的loss计算公式：<br>$$<br>L = \alpha L_C + (1 - \alpha) L_S + \beta L_O<br>$$</p>
<p>$L$是总的loss，$L_C$是center loss，$L_S$是softmax loss，$L_O$是细节点方向loss。<br>$\alpha$和$\beta$是各个loss的平衡常数，$\alpha = 0.5$，$\beta = 2$。</p>
<p>&emsp;&emsp;<strong>参数设置</strong>：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">网络参数初始化</td>
<td align="left">$N(0, 0.01)$的随机高斯分布</td>
</tr>
<tr>
<td align="left">batch size</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">学习率</td>
<td align="left">初始学习率0.1，每迭代5万次除以10</td>
</tr>
<tr>
<td align="left">最大迭代次数</td>
<td align="left">20万</td>
</tr>
<tr>
<td align="left">动量</td>
<td align="left">0.9</td>
</tr>
<tr>
<td align="left">权重衰减</td>
<td align="left">0.0004</td>
</tr>
</tbody></table>
<h1 id="Experimental-results（实验结果）"><a href="#Experimental-results（实验结果）" class="headerlink" title="Experimental results（实验结果）"></a>Experimental results（实验结果）</h1><h2 id="Datasets（数据集）"><a href="#Datasets（数据集）" class="headerlink" title="Datasets（数据集）"></a>Datasets（数据集）</h2><p>&emsp;&emsp;CoarseNet的训练数据包括FVC 2002数据集和用其增强后的数据，共8000张图像。FineNet的训练数据包括100K个细节点和非细节点块。</p>
<h2 id="Evaluation（评估）"><a href="#Evaluation（评估）" class="headerlink" title="Evaluation（评估）"></a>Evaluation（评估）</h2><p>&emsp;&emsp;评估的数据库是FVC 2004和NIST SD27。用$(l_p, o_p)$表示预测的细节点坐标和方向，$(l_{gt}, o_{gt})$表示ground truth细节点。如果预测的细节点满足以下条件，说明预测正确。<br>$$<br>\begin{cases}<br>    \parallel l_p - l_{gt} \parallel_2 \leq D \\<br>    \parallel o_p - o_{gt} \parallel_1 \leq O<br>\end{cases}<br>$$</p>
<p>&emsp;&emsp;$D$和$O$是位置偏差和角度偏差的阈值。<br>&emsp;&emsp;表2统计了$(D = 8, O = 10)$、$(D = 12, O = 20)$、$(D = 16, O = 30)$的准确率、召回率和F1分数。<br><img src="/images/paper/minutiae_net/tabel_2.png" alt="" title="表2 不同的细节提取方法在FVC 2004和NIST SD27数据集的比较"></p>
<p>&emsp;&emsp;表3是使用FingerNet的非极大值抑制(NMS)和作者提出的非极大值抑制(NMS*)的比对，对比数据库是NIST SD27。<br><img src="/images/paper/minutiae_net/table_3.png" alt="" title="表3 两种非极大值抑制方法的比较"></p>
<p>&emsp;&emsp;图6是不同方法的准确率和召回率曲线对比。<br><img src="/images/paper/minutiae_net/figure_6.png" alt="" title="图6 不同方法的准确率和召回率曲线对比"></p>
<p>&emsp;&emsp;图7是细节点提取的效果图。<br><img src="/images/paper/minutiae_net/figure_7.png" alt="" title="图7 细节点提取的效果图"></p>
<p>&emsp;&emsp;在某些情况下，提议的框架会遗漏了真细节点，或者提取了伪细节点。由于脊线的不连续，导致一些细节点检测错误(图像a)，或者由于细节点的位置靠近指纹边缘而漏检(图像c)。对于NIST SD27数据集的潜在指纹，该方法对严重的背景噪声(图像exiang指纹质量(图像g)比较敏感。对于FVC 2004数据集和NIST SD27数据集的滚动指纹，得到了接近ground truth的结果。<br>&emsp;&emsp;NIST SD27每张图片的运行时间约为1.5秒，FVC 2004每张图片的运行时间约为1.2秒。</p>
<h1 id="Conclusions（总结）"><a href="#Conclusions（总结）" class="headerlink" title="Conclusions（总结）"></a>Conclusions（总结）</h1><p>&emsp;&emsp;提出了两个细节点提取网络：CoarseNet和FineNet。提出了一个非极大抑制方法。</p>
<p>改进的地方：</p>
<ol>
<li>使用更大的包括现场指纹的训练集来训练。</li>
<li>构建背景描述符来利用细节点周围的区域。</li>
<li>改进处理时间。</li>
<li>将细节点提取器整合到端到端指纹匹配框架中。</li>
</ol>
]]></content>
      <categories>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>深度学习</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
</search>
